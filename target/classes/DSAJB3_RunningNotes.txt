Good evening

welcome to durgasoft onlinetraining

welcome to "Data Structures and Algorithms (DSA with Java)" course

K Prakash Babu, 15 Years of Exp as trainer.

course -----------> Data Structures and Algorithms with Java
pre-requisite ----> core java must be required
duration ---------> 2 to 3 months 
timings ----------> 5pm to 6pm [mon-fri]
fees -------------> Rs. 999/-
contact ----------> 720721 2427

running notes will be shared on daily basis
videos will be shared for you with 7-months access
java is mandatory for this batch

Demos's: 
https://www.youtube.com/watch?v=lvDMqk2HPsU&list=PLd3UqWTnYXOkZJT5XxOuK5_oqE0cTLNrb

syllabus:
---------
Chapter: 01 Introduction to DSA
Chapter: 02 Problem Solving
Chapter: 03 Time and Space Complexity
Chapter: 04 Notations
Chapter: 05 Aspects of Algorithms
Chapter: 06 Mathematical Algorithms
Chapter: 07 Bitwise opertations
Chapter: 08 Recursion
Chapter: 09 Arrays, Strings
Chapter: 10 Matrix
Chapter: 11 Searching and Sorting Techniques
Chapter: 12 LinkedLists
Chapter: 13 Stacks (LIFO)
Chapter: 14 Queues
Chapter: 15 Binary Trees
Chapter: 16 Hashtables
Chapter: 17 Hashing
Chapter: 18 AVL Tree
Chapter: 19 Dictionaries or Maps
Chapter: 20 Graph
Chapter: 21 Greedy
Chapter: 22 Backtracking
Chapter: 23 Dynamic programming


Realtime examples for data structures:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
01. Music Players ----------> Spotify, Jio Savan, Prime Music etc -----> SLL,DLL,CSLL,CDLL
02. Bookmyshow -------------> Online movie ticket reservation ---------> Arrays
03. spam emails ------------> email filtering -------------------------> String
04. Credit amount in to A/C-> bank ------------------------------------> Queue
05. Navigations ------------> src to dest -----------------------------> Graph



Algorithm:
~~~~~~~~~~
step by step process for solving a problem is called as an algorithm, here will concentrate more on design part rather than implementation. instructions will be just like our english statements.

Ex:
---

addition of two numbers

01. read two numbers from the user 'a' and 'b'.
02. compute the value 'c' based on the following math formula.
03. c=a+b;
04. return or print the value

FlowChart:
~~~~~~~~~~
digrametic or pictorial representation of an algorithm is called as flow chart.

Implementation:
~~~~~~~~~~~~~~~
Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args)
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter first number:");
		int a = obj.nextInt();

		System.out.println("Enter second number:");
		int b = obj.nextInt();

		int c = a+b;

		System.out.println(c);
	}
}

output:
--------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter first number:
10
Enter second number:
20
30

Ex:
---
import java.util.*;

class Demo
{
	static int add(int a,int b)
	{
		return a+b;
	}
}

class Test 
{
	public static void main(String[] args)
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter first number:");
		int a = obj.nextInt();

		System.out.println("Enter second number:");
		int b = obj.nextInt();

		System.out.println(Demo.add(a,b));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter first number:
111
Enter second number:
222
333




01. max of two numbers
02. sum of 'n' natural numbers
03. factorial of the given number
04. swaping of two integer values
05. prime number or not
06. max of three numbers
07. fib sequence
08. trib sequence


01. max of two numbers
-----------------------
Here we have supply two integer values, and we required to find max or biggest of 'a' and 'b'.

Ex:
---
	10,11 ----> 11
	10,3 -----> 10

Algorithm:
----------
			1. read two integer values from the user.
			2. apply business logic.

				logic1: by using conditional operator
				--------------------------------------
				(condition)?TB:FB
				(a>b)?a:b

				logic2: by using predefined methods
				-----------------------------------
				Math.max(a,b)

			3. print the result.

Ex:
---
import java.util.*;

class Demo
{
	static int maxv1(int a,int b){
		return (a>b)?a:b;
	}

	static int maxv2(int a,int b){
		return Math.max(a,b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		System.out.println(Demo.maxv1(a,b));
		System.out.println(Demo.maxv2(a,b));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter a value:
10
Enter b value:
20
20
20

C:\prakashclasses>java Test
Enter a value:
10
Enter b value:
-20
10
10

06. max of three numbers
------------------------
Here we have supply three integer values, and we required to find max or biggest of 'a', 'b' and 'c'.

Ex:
---
	10,11,12 ----> 12
	10,11,-12 ---> 11
	10,-11,-12 --> 10

Algorithm:
----------
			1. read three integer values from the user.
			2. apply business logic.

				logic1: by using conditional operator
				--------------------------------------
				(condition)?TB:FB
				(a>b && a>c)?a:(b>c?b:c)

				logic2: by using predefined methods
				-----------------------------------
				Math.max(Math.max(a,b),c)

			3. print the result.

Ex:
---
import java.util.*;

class Demo
{
	static int maxv1(int a,int b,int c){
		return (a>b && a>c)?a:(b>c?b:c);
	}

	static int maxv2(int a,int b,int c){
		return Math.max(Math.max(a,b),c);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		System.out.println("Enter c value:");
		int c = obj.nextInt();

		System.out.println(Demo.maxv1(a,b,c));
		System.out.println(Demo.maxv2(a,b,c));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter a value:
1
Enter b value:
2
Enter c value:
3
3
3

C:\prakashclasses>java Test
Enter a value:
1
Enter b value:
2
Enter c value:
-3
2
2

C:\prakashclasses>java Test
Enter a value:
1
Enter b value:
-2
Enter c value:
-3
1
1

02. sum of 'n' natural numbers
------------------------------
0+1+2+3+4+5+.....+n = sum of 'n' natural numbers

n=0 -----> 0
n=1 -----> 0+1=1
n=2 -----> 0+1+2=3
n=3 -----> 0+1+2+3=6
n=4 -----> 0+1+2+3+4=10
n=5 -----> 0+1+2+3+4+5=15

Algorithm:
----------
			1. read 'n' value from the user.
			2. apply business logic

			logic1: by using math formaula
			------------------------------
			n(n+1)/2

			logic2: by using looping
			------------------------
			s=0
			for(i=0;i<n;i++)
			{
				s=s+i;
			}
			print s

			logic3: by using recursion
			--------------------------
			int sum(int n)
			{
				if(n==0)
					return 0;
				else
					return n+sum(n-1);
			}

			3. print the result on the screen

Ex:
---
import java.util.*;

class Demo
{
	static int sumv1(int n){
		return (n*(n+1))/2;
	}

	static int sumv2(int n){
		int i,s=0;
		for(i=0;i<=n;i++)
			s=s+i;
		return s;
	}

	static int sumv3(int n){
		if(n==0)
			return 0;
		else
			return n+sumv3(n-1);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter n value:");
		int n = obj.nextInt();

		System.out.println(Demo.sumv1(n));
		System.out.println(Demo.sumv2(n));
		System.out.println(Demo.sumv3(n));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter n value:
5
15
15
15

C:\prakashclasses>java Test
Enter n value:
3
6
6
6

C:\prakashclasses>java Test
Enter n value:
7
28
28
28

C:\prakashclasses>java Test
Enter n value:
0
0
0
0






03. factorial of the given number
---------------------------------
Implement an algorithm and program to find factorial of the given number. 

Ex:
---
	5! = 5x4x3x2x1x0! = 5x4x3x2x1x1 = 120
	0! = 1
	2! = 2x1x0! = 2x1x1 = 2

Algorithm:
----------
			1. read 'n' value from the user.
			2. apply business logic
			logic1: by using looping
			------------------------
			f=1;
			for(i=1;i<=n;i++)
			{
				f=f*i;
			}
			print f

			logic2: by using recursion
			--------------------------
			int fact(int n)
			{
				if(n==1)
					return 1;
				else
					return n*fact(n-1);
			}
			3. print the result

Ex:
---
import java.util.*;

class Demo
{
	static int factv1(int n)
	{
		int f=1,i;
		for(i=1;i<=n;i++)
			f=f*i;
		return f;
	}
	static int factv2(int n)
	{
		if(n==0)
			return 1;
		else
			return n*factv2(n-1);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter n value:");
		int n = obj.nextInt();

		System.out.println(Demo.factv1(n));
		System.out.println(Demo.factv2(n));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter n value:
5
120
120

04. swaping of two integer values
----------------------------------
swaping means interchanging the values.

Ex:
---
	a=10,b=20 -----> a=20,b=10

Algorithm:
----------
			1. read 'a' and 'b' values from the user.
			2. before swaping print the values of 'a' and 'b'
			3. apply business logic
			logic1: by using temp variable
			-------------------------------
			temp=a;
			a=b;
			b=temp;

			logic2: by using addition and sub
			---------------------------------
			a=a+b;
			b=a-b;
			a=a-b;

			logic3: by using mul and div
			----------------------------
			a=a*b;
			b=a/b;
			a=a/b;

			logic4: by using bitwise operators
			----------------------------------
			a=a^b
			b=a^b
			a=a^b

			logic5: by using single line statement
			---------------------------------------
			a=a+b-b=a;

			4. after swaping print the values of 'a' and 'b'

Ex:
---
import java.util.*;

class Demo
{
	static void swap1(int a,int b){
		System.out.println("Before swaping a="+a+" and b="+b);
		int t;
		t=a;
		a=b;
		b=t;
		System.out.println("After swaping a="+a+" and b="+b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		Demo.swap1(a,b);
	}
}

output:
-------
Enter a value:
10
Enter b value:
20
Before swaping a=10 and b=20
After swaping a=20 and b=10

Ex:
---
import java.util.*;

class Demo
{
	static void swap1(int a,int b){
		System.out.println("Before swaping a="+a+" and b="+b);
		a=a+b;
		b=a-b;
		a=a-b;
		System.out.println("After swaping a="+a+" and b="+b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		Demo.swap1(a,b);
	}
}

output:
-------
Enter a value:
111
Enter b value:
222
Before swaping a=111 and b=222
After swaping a=222 and b=111

Ex:
---
import java.util.*;

class Demo
{
	static void swap1(int a,int b){
		System.out.println("Before swaping a="+a+" and b="+b);
		a=a*b;
		b=a/b;
		a=a/b;
		System.out.println("After swaping a="+a+" and b="+b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		Demo.swap1(a,b);
	}
}

output:
-------
Enter a value:
5
Enter b value:
3
Before swaping a=5 and b=3
After swaping a=3 and b=5

Ex:
---
import java.util.*;

class Demo
{
	static void swap1(int a,int b){
		System.out.println("Before swaping a="+a+" and b="+b);
		a=a^b;
		b=a^b;
		a=a^b;
		System.out.println("After swaping a="+a+" and b="+b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		Demo.swap1(a,b);
	}
}

output:
------
Enter a value:
3
Enter b value:
4
Before swaping a=3 and b=4
After swaping a=4 and b=3

Ex:
---
import java.util.*;

class Demo
{
	static void swap1(int a,int b){
		System.out.println("Before swaping a="+a+" and b="+b);
		a=a+b-(b=a);
		System.out.println("After swaping a="+a+" and b="+b);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter a value:");
		int a = obj.nextInt();

		System.out.println("Enter b value:");
		int b = obj.nextInt();

		Demo.swap1(a,b);
	}
}

output:
-------
Enter a value:
10
Enter b value:
11
Before swaping a=10 and b=11
After swaping a=11 and b=10

05. prime number or not
-----------------------
a number is said to be prime, if it is divisible by one and itself. i.e. factors is equal to 2.

Algorithm:
----------
			1. read 'n' value from the user.
			2. business logic

			logic1: by using iteration (loop)
			---------------------------------
			factors=0;
			for(i=1;i<=n;i++)
			{
				if(n%i==0)
					factors++;
			}
			if factors==2 then print 'true' else 'false'

			logic2: by using recursion 
			--------------------------
			boolean isprime2(int n,int i)
			{
				if(n==1)
					return true;
				else if(n%i==0)
					return false;
				else
					return isprime2(n,--i);
			}

			3. print true or false.
Ex:
---
import java.util.*;

class Demo
{
	static boolean isprime1(int n){
		int f=0,i;
		for(i=1;i<=n;i++){
			if(n%i==0)
				f++;
		}
		return f==2;
	}

	static boolean isprime2(int n,int i){
		if(i==1)
			return true;
		else if(n%i==0)
			return false;
		else
			return isprime2(n,--i);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter n value:");
		int n= obj.nextInt();

		System.out.println(Demo.isprime1(n));
		System.out.println(Demo.isprime2(n,n/2));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter n value:
5
true
true

C:\prakashclasses>java Test
Enter n value:
6
false
false

C:\prakashclasses>java Test
Enter n value:
10
false
false

C:\prakashclasses>java Test
Enter n value:
11
true
true

07. fib sequence
08. trib sequence


IMPLEMENT A ALGO/PROGRAM TO GENERATE FIBNOCCI NUMBERS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 1 2 3 5 8 13 ......

FIB Seq ---> every number is sum of previous two numbers

ALGO:
-----
	1. read 'n' value from the user.
	2. create an empty ArrayList object [container to hold all numbers]
	3. push all calcualted fib numbers into ArrayList object.

	logic:
	------
			ArrayList<Integer> obj = new ArrayList<Integer>();
			a=0
			b=1
			obj.add(a);
			obj.add(b);
			for(i=1;i<=n-2;i++)
			{
				c=a+b;
				obj.add(c);
				a=b;
				b=c;
			}

	4. print ArrayList object

Implementation:
---------------
import java.util.*;

class Demo
{
	static ArrayList<Integer> getFibSeq(int n)
	{
		ArrayList<Integer> obj = new ArrayList<Integer>();

		int a,b,c,i;

		a=0;
		b=1;
		obj.add(a);
		obj.add(b);

		for(i=1;i<=n-2;i++){
			c=a+b;
			obj.add(c);
			a=b;
			b=c;
		}

		return obj;
	}
}


class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter n value:");
		int n = obj.nextInt();

		System.out.println(Demo.getFibSeq(n));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter n value:
2
[0, 1]

C:\prakashclasses>java Test
Enter n value:
3
[0, 1, 1]

C:\prakashclasses>java Test
Enter n value:
4
[0, 1, 1, 2]

C:\prakashclasses>java Test
Enter n value:
5
[0, 1, 1, 2, 3]

IMPLEMENT A ALGO/PROGRAM TO GENERATE TRIBONCCI NUMBERS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 2 ----> 0 1 2 3 6 11 20 ....

ALGO:
-----
		1. read 'n' value from the user.
		2. create an array with size n.
		3. push all the calcualted trib seq values into an array.

		logic:
		------
				a=0;
				b=1;
				c=2;
				arr[0] = a;
				arr[1] = b;
				arr[2] = c;
				for(i=3;i<n;i++)
				{
					d=a+b+c;
					arr[i]=d;
					a=b;
					b=c;
					c=d;
				}

		4. print the result array

IMPLEMENTATION:
---------------
import java.util.*;

class Demo
{
	static int[] getTribSeq(int n)
	{
		int arr[] = new int[n];

		int a,b,c,d,i;
		a=0;
		b=1;
		c=2;
		arr[0] = a;
		arr[1] = b;
		arr[2] = c;

		for(i=3;i<n;i++){
			d=a+b+c;
			arr[i]=d;
			a=b;
			b=c;
			c=d;
		}

		return arr;
	}
}


class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter n value:");
		int n = obj.nextInt();

		System.out.println(Arrays.toString(Demo.getTribSeq(n)));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter n value:
5
[0, 1, 2, 3, 6]




Arrays:
-------

Introduction to array:
~~~~~~~~~~~~~~~~~~~~~~
=> a variable can hold only one value at a time.

Ex:
---
	a = 10;
	System.out.println(a);//10
	a = 20;
	System.out.println(a);//20

=> if we want to represent/hold more values, then variables are not recommended.

Ex:
---
	int s1;
	int s1,s2;
	int s1,s2,s3;
	int s1,s2,s3,s4;
	int s1,s2,s3,s4,s5;
	int s1,s2,s3,s4,s5,.....s50;

=> sum of all these marks

	s1+s2+s3+s4+s5+.....+s50

=> to overcome these problems, we should go for arrays.

=> an array is group of or collection of similar type of elements or values or items.

=> all these values must be of same type.

=> all these values are identified by using common name.

=> all these values we can access by using 'index' concept.

Ex:
---
	int a1,a2,a3,a4,a5,a6,a7,a8,a9,a10;

	int a[10];

	a[0]
	a[1]
	a[2]
	.
	.
	a[n-1]

	where n= number of elements in array
	index  = 0 to n-1 ---> 0 to 9
	[] -----> subscripts

=> In java array is considered as an object.

=> In java array is a data structure.

Ex:
---
	c --------> int a[10];
	c++ ------> int a[10];
	java -----> int a[] = new int[10];
	py -------> arrays concept is not there (list or array module)

advantages of arrays:
---------------------
1. it collects group of items.
2. only one name is sufficient to represent all the values.
3. we have index support is there.
4. insertion order is preserved.
5. duplicate values are allowed.

disadvantage of arrays:
-----------------------
1. it is fixed in size [not growable].
2. it collects only same type of elements [homogeneous].
3. no inbuilt method. (no predefined methods).

variables -----> arrays ------> Abstract Data Type (ADTs) or Collections

a.length() ----> invalid
a.length ------> valid

declaration of an array:
~~~~~~~~~~~~~~~~~~~~~~~~
Once if we are using any variable or an array. In java, first we have to declare that variable. To declare arrays in java the following syntax is used.

syntax:
-------
		datatype arrayname[];
		datatype arrayname[][];
		datatype arrayname[][][];
		datatype arrayname[]......[];

		[] ----> 1-D
		[][] --> 2-D
		[]..[]-> n-D

Ex:
---
		int a[];
		int []a;
		int[] a; ----> recommended

Ex:
---
		int a[][];
		int [][]a;
		int []a[];
		int[] a[];
		int[] []a;
		int[][] a; ----> recommended

Note: At the time of declaration of an array, we should not provide size of the array like other programming languages.

	int a[]; ------> valid in java but invalid in c-lang
	int a[3]; -----> valid in c-lang but invalid in java

Note: Internally arrays are created in java by ADTs only.

class [I {}
class [[I{}
class [F {}

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {1,2,3,4};
		float b[] = {1.2F,3.4F};
		int c[][]={{1,2},{3,4}};

		System.out.println(a);
		System.out.println(b);
		System.out.println(c);
	}
}

output:
-------
[I@76ed5528
[F@2c7b84de
[[I@3fee733d


creation of an array:
~~~~~~~~~~~~~~~~~~~~~
Once if an array is declared, we have to allocate memory for that array, it is possible by using creation of array, we can use 'new' keyword to create array in java. the following syntax is used to create an array.

syntax:
-------
		datatype arrayname[];
		arrayname = new datatype[size];

		or

		datatype arrayname[] = new datatype[size];

Ex:
---
		int a[];
		a = new int[4];

		or

		int a[] = new int[4];

Ex:
---
		int a[] = new int[3];
		double b[] = new double[5];
		String names[] = new String[100];
		Emp e[] = new Emp[10];

		int x[][] = new int[3][3];

memory representation of an array:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diagram

intialization of an array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~
In c-lang and c++ programming, default values concept is not existed, hence we have to intialize the values manually. In java, default values concept is there. ie. if we are not providing any intial values, then default values will be considered, if we want we can supply dynamic values manually. the following are the default values.

primitives -------> 0, 0.0, '', false
objects ----------> null

Ex:
---
		int a[] = new int[3];

		System.out.println(a[0]);//0
		System.out.println(a[1]);//0
		System.out.println(a[2]);//0

Ex:
---
		int a[] = new int[3];

		System.out.println(a[0]);//0
		System.out.println(a[1]);//0
		System.out.println(a[2]);//0

		a[0] = 111;
		a[1] = 222;
		a[2] = 333;

		System.out.println(a[0]);//111
		System.out.println(a[1]);//222
		System.out.println(a[2]);//333

Ex:
---
		boolean b[] = new boolean[4];

		System.out.println(b[0]);//false
		System.out.println(b[1]);//false
		System.out.println(b[2]);//false
		System.out.println(b[3]);//false

Ex:
---
		boolean b[] = new boolean[4];

		b[0] = true;
		b[2] = true;

		System.out.println(b[0]);//true
		System.out.println(b[1]);//false
		System.out.println(b[2]);//true
		System.out.println(b[3]);//false

Ex:
---
		String names[] = new String[3];

		names[1] = "Prakash";

		System.out.println(names[0]);//null
		System.out.println(names[1]);//Prakash
		System.out.println(names[2]);//null


array declaration, creation and intialization in single line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ex:
---
		int a[];
		a = new int[3];
		a[0] = 111;
		a[1] = 222;
		a[2] = 333;

		or

		int a[] = {111, 222, 333};

		size: 3
		dim : 1
		name: a
		type: int

Ex:
---
		int a[][] = {{11, 22, 33},{44, 55},{66, 77, 88, 99}};

		a[0][0] ----> 11
		a[0][1] ----> 22
		a[0][2] ----> 33

		a[1][0] ----> 44
		a[1][1] ----> 55

		a[2][0] ----> 66
		a[2][1] ----> 77
		a[2][2] ----> 88
		a[2][3] ----> 99




length identifier:-
~~~~~~~~~~~~~~~~~~~
it is used to find length of the given array.

Ex:
---
	int a[] = new int[4];

	System.out.println(a.length); ----> 4

Ex:
---
	int a[][] = new int[3][4];

	System.out.println(a.length); ----> error

	System.out.println(a[0].length); ----> 4
	System.out.println(a[1].length); ----> 4
	System.out.println(a[2].length); ----> 4

Ex:
---
	int a[][] = {{11, 22, 33},{44, 55},{66, 77, 88, 99}};

	a[0].length -----> 3
	a[1].length -----> 2
	a[2].length -----> 4




index concept:
--------------
=> we can traverse or retrive array elements by using 'index' concept.
=> index is always an integer value.
=> it must be always +ve index.
=> we have to enclose this index value inside subscript [].

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = new int[3];

		System.out.println(a[0]);//0
		System.out.println(a[1]);//0
		System.out.println(a[2]);//0

		a[0] = 111;
		a[1] = 222;
		a[2] = 333;

		System.out.println(a[0]);//111
		System.out.println(a[1]);//222
		System.out.println(a[2]);//333		
	}
}


output:
-------
0
0
0
111
222
333

ArrayIndexOutOfBoundsException:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If we are trying to access the elements, which are not in our range (0 to len of array-1), then we are getting runtime error saying "ArrayIndexOutOfBoundsException".

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = new int[3];

		System.out.println(a[4]);//AIOBE	
	}
}


output:
-------
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 3
        at Test.main(Test.java:9)

NegativeArraySizeException:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
when we are creating an array, if we are trying to provide size of the array as negative numbers, then we will get runtime error saying "NegativeArraySizeException".

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = new int[-3];
	}
}

output:
-------
Exception in thread "main" java.lang.NegativeArraySizeException: -3
        at Test.main(Test.java:7)

Reading and Writing Array Elements:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If we want perform operations on array, then we have to ready dynamic data from the user and we have to print the array on console. to perform these activites the following are the syntaxes for reading and writing array elements.

Reading:-
-------
Scanner -----> it is used to read primtive data, i.e. int, float, char, boolean string

Scanner obj = new Scanner(System.in);

obj.nextInt()         ------> read int value
obj.nextDouble()          --> read double value
obj.nextBoolean()         --> read boolean value
obj.nextLine()        ------> read string value
obj.nextLine().charAt(0) ---> read char value

Writing array elements:
-----------------------
The following are the different ways to print array elements on the console.

1) index concept
2) while loop
3) for loop
4) for each loop
5) Arrays.toString(--)

Ex:
---
		int a[] = {11, 22, 55, 33};

		index:
				a[0]
				a[1]
				a[2]
				a[3]

		while:

				index=0;
				while(index<a.length)
				{
					print a[index]
					index++;
				}
		
		for loop:

				for(i=0;i<a.length;i++)
				{
					print a[i]
				}

		for each loop:

				for(int item:a)
				{
					print item
				}

		Arrays.toString(--);

				Arrays.toString(a);

				[1, 2, 3, 4, 5]

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n=obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" elements:");
		for(i=0;i<n;i++)
			a[i] = obj.nextInt();

		System.out.println("The array elements are:");
		for(i=0;i<n;i++)
		{
			System.out.println(a[i]);
		}
	}
}

output:
-------
Enter size of the array:
5
Enter 5 elements:
11 22 33 44 55
The array elements are:
11
22
33
44
55

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {111, 222, 333, 444, 555};
		int i,n = a.length;

		//by using index concept
		System.out.println("by using index concept");
		System.out.println(a[0]);
		System.out.println(a[1]);
		System.out.println(a[2]);
		System.out.println(a[3]);
		System.out.println(a[4]);

		//by using while loop
		System.out.println("by using while loop..");
		i=0;
		while(i<n)
		{
			System.out.println(a[i]);
			i++;
		}

		//by using for loop
		System.out.println("by using for loop...");
		for(i=0;i<n;i++)
		{
			System.out.println(a[i]);
		}

		//by using for-each loop
		System.out.println("by using for-each loop...");
		for(int item:a)
		{
			System.out.println(item);	
		}

		//by using toString
		System.out.println("by using toString method...");
		System.out.println(Arrays.toString(a));

	}
}

output:
-------
by using index concept
111
222
333
444
555
by using while loop..
111
222
333
444
555
by using for loop...
111
222
333
444
555
by using for-each loop...
111
222
333
444
555
by using toString method...
[111, 222, 333, 444, 555]

Array Programs:-
---------------
1) Reading and Writing Array Elements
-------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
	}
}


output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 2 3 4 5
Array = [1, 2, 3, 4, 5]

Sum of all elements present in an array
---------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
		//business logic
		int s=0;
		for(int item:a)
		{
			s=s+item;
		}
		System.out.println("Sum="+s);
	}
}


output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 2 3 4 5
Array = [1, 2, 3, 4, 5]
Sum=15

Enter size of the array:
4
Enter 4 Elements...
1 9 10 9
Array = [1, 9, 10, 9]
Sum=29




sum of even elements in an array:
---------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
		//business logic
		int s=0;
		for(int item:a)
		{
			if(item%2==0)
				s=s+item;
		}
		System.out.println("Sum="+s);
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 2 3 4 5
Array = [1, 2, 3, 4, 5]
Sum=6

Enter size of the array:
5
Enter 5 Elements...
1 3 5 7 9
Array = [1, 3, 5, 7, 9]
Sum=0

sum of odd numbers
------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
		//business logic
		int s=0;
		for(int item:a)
		{
			if(item%2!=0)
				s=s+item;
		}
		System.out.println("Sum="+s);
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 2 3 4 5
Array = [1, 2, 3, 4, 5]
Sum=9

Enter size of the array:
5
Enter 5 Elements...
2 4 6 8 10
Array = [2, 4, 6, 8, 10]
Sum=0

sum of +ve elements in an array----------------------> if(item>=0)
sum of -ve elements in an array----------------------> if(item<0)
sum of elements which are ending with 3 in an array--> if(item%10==3)
sum of elements which are divisible by 3 in an array-> if(item%3==0)
sum of prime elements in an array--------------------> if(isprime(item))


max element in an array:-
~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
		//business logic
		int max;
		max=a[0];
		for(i=1;i<n;i++)
		{
			if(max<a[i])
				max=a[i];
		}
		System.out.println("max element in array is = "+max);
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
5
2
1
8
4
Array = [5, 2, 1, 8, 4]
max element in array is = 8

min element in an array:-
~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array = "+Arrays.toString(a));		
		//business logic
		int min;
		min=a[0];
		for(i=1;i<n;i++)
		{
			if(min>a[i])
				min=a[i];
		}
		System.out.println("min element in array is = "+min);
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
5
2
1
8
4
Array = [5, 2, 1, 8, 4]
max element in array is = 1

sorting array elements:-
~~~~~~~~~~~~~~~~~~~~~~~
[3, 1, 5, 2, 4] sort in asc order ----> [1, 2, 3, 4, 5]
[3, 1, 5, 2, 4] sort in desc order ---> [5, 4, 3, 2, 1]

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array before sorting = "+Arrays.toString(a));		
		//business logic
		int j,temp;
		for(i=0;i<n;i++)
		{
			for(j=i+1;j<n;j++)
			{
				if(a[i]>a[j])
				{
					temp = a[i];
					a[i] = a[j];
					a[j] = temp;
				}
			}
		}
		System.out.println("Array after sorting asc order = "+Arrays.toString(a));	
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 5 2 4 3
Array before sorting = [1, 5, 2, 4, 3]
Array after sorting asc order = [1, 2, 3, 4, 5]

Ex:
----
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array before sorting = "+Arrays.toString(a));		
		//business logic
		int j,temp;
		for(i=0;i<n;i++)
		{
			for(j=i+1;j<n;j++)
			{
				if(a[i]<a[j])
				{
					temp = a[i];
					a[i] = a[j];
					a[j] = temp;
				}
			}
		}
		System.out.println("Array after sorting desc order = "+Arrays.toString(a));	
	}
}

output:
-------
Enter size of the array:
5
Enter 5 Elements...
1 5 2 4 3
Array before sorting = [1, 5, 2, 4, 3]
Array after sorting desc order = [5, 4, 3, 2, 1]

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter size of the array:");
		int n = obj.nextInt();

		int a[] = new int[n];

		int i;

		System.out.println("Enter "+n+" Elements...");
		for(i=0;i<n;i++)
		{
			a[i] = obj.nextInt();
		}		

		System.out.println("Array before sorting = "+Arrays.toString(a));		
		//business logic
		Arrays.sort(a);
		System.out.println("Array after sorting desc order = "+Arrays.toString(a));	
	}
}

output:
-------
Enter size of the array:
8
Enter 8 Elements...
2 1 7 3 5 9 4 6
Array before sorting = [2, 1, 7, 3, 5, 9, 4, 6]
Array after sorting desc order = [1, 2, 3, 4, 5, 6, 7, 9]




sorting array in asc order ----> user defined
sorting array in desc order ---> user defined
sorting array in asc order ----> predefined ---> Arrays.sort(a);

max element in an array
min element in an array

sort the array asc ---> a ---> 1stsmall, 2nd small, 3rd small, .....2nd max, 1st max

1st max ------> a[n-1]         1st min -------> a[1-1]
2nd max ------> a[n-2]         2nd min -------> a[2-1]
3rd max ------> a[n-3]         3rd min -------> a[3-1]

kth max ------> a[n-k]         kth min -------> a[k-1]
and so on

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();

		int a[] = new int[10];

		for(int i=0;i<a.length;i++)
		{
			a[i] = r.nextInt(100);//it generates random number from 0 to 100
		}

		System.out.println(Arrays.toString(a));

	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[79, 8, 90, 78, 84, 64, 50, 39, 24, 89]

C:\prakashclasses>java Test
[38, 80, 23, 60, 16, 86, 48, 15, 91, 93]

C:\prakashclasses>java Test
[16, 1, 0, 61, 26, 66, 48, 39, 88, 8]


Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();

		int a[] = new int[10];

		for(int i=0;i<a.length;i++)
		{
			a[i] = r.nextInt(100);//it generates random number from 0 to 100
		}

		System.out.println("Before Sorting===>"+ Arrays.toString(a));
		Arrays.sort(a);
		System.out.println("After Sorting===>"+ Arrays.toString(a));

		System.out.println("1st max = "+a[a.length-1]+"\t1st min = "+a[1-1]);
		System.out.println("2nd max = "+a[a.length-2]+"\t2nd min = "+a[2-1]);
		System.out.println("3rd max = "+a[a.length-3]+"\t3rd min = "+a[3-1]);
	}
}

output:
-------
Before Sorting===>[61, 73, 55, 10, 64, 92, 85, 4, 78, 76]
After Sorting===>[4, 10, 55, 61, 64, 73, 76, 78, 85, 92]
1st max = 92    1st min = 4
2nd max = 85    2nd min = 10
3rd max = 78    3rd min = 55

searching ----> linear and binary search
----------------------------------------
Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();

		int a[] = new int[10];

		for(int i=0;i<a.length;i++)
		{
			a[i] = r.nextInt(100);//it generates random number from 0 to 100
		}

		System.out.println(Arrays.toString(a));

		//linear search

		System.out.println("Enter key element to search:");
		int key=obj.nextInt();

		int i,index=-1;

		for(i=0;i<a.length;i++){
			if(key==a[i]){
				index=i;
				break;
			}
		}

		System.out.println("location= "+index);
	}
}

output:
-------
[19, 50, 68, 79, 94, 13, 39, 56, 93, 40]
Enter key element to search:
39
location= 6

[73, 72, 68, 86, 0, 73, 86, 44, 58, 50]
Enter key element to search:
55
location= -1

binary search:
--------------
the array must be in sorted order..

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();

		int a[] = new int[10];

		for(int i=0;i<a.length;i++)
		{
			a[i] = r.nextInt(100);//it generates random number from 0 to 100
		}

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));

		//linear search

		System.out.println("Enter key element to search:");
		int key=obj.nextInt();

		int index=-1,low,high,mid;
		low=0;
		high=a.length-1;

		while(low<=high){
			mid=(low+high)/2;
			if(a[mid]==key)
			{
				index=mid;
				break;
			}
			else if(a[mid]>key)
				high=mid-1;
			else
				low=mid+1;
		}

		System.out.println("location= "+index);
	}
}

output:
-------
[35, 87, 94, 59, 14, 7, 98, 14, 78, 95]
[7, 14, 14, 35, 59, 78, 87, 94, 95, 98]
Enter key element to search:
87
location= 6

[89, 79, 29, 72, 17, 58, 67, 29, 13, 67]
[13, 17, 29, 29, 58, 67, 67, 72, 79, 89]
Enter key element to search:
90
location= -1

eqaulity of arrays:-
~~~~~~~~~~~~~~~~~~~
case1: by checking manually
case2: by checking manually and ignoring order
case3: by using predefined methods
case4: by using predefined methods and ignoring order

case1: by checking manually
---------------------------
import java.util.*;

class Demo{
	static boolean myEqual(int a[],int b[]){
		for(int i=0;i<a.length;i++){
			if(a[i]!=b[i])
				return false;
		}
		return true;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		
		int w[] = {1, 2, 3};
		int x[] = {4, 5, 6};
		int y[] = {1, 2, 3};
		int z[] = {1, 3, 2};

		System.out.println("w==>"+Arrays.toString(w));
		System.out.println("x==>"+Arrays.toString(x));
		System.out.println("y==>"+Arrays.toString(y));
		System.out.println("z==>"+Arrays.toString(z));

		System.out.println("w==x : "+Demo.myEqual(w,x));//false
		System.out.println("w==y : "+Demo.myEqual(w,y));//true
		System.out.println("w==z : "+Demo.myEqual(w,z));//false
	}
}

output:
-------
w==>[1, 2, 3]
x==>[4, 5, 6]
y==>[1, 2, 3]
z==>[1, 3, 2]
w==x : false
w==y : true
w==z : false

case2: by checking manually and ignoring order
----------------------------------------------
import java.util.*;

class Demo{
	static boolean myEqual(int a[],int b[]){
		for(int i=0;i<a.length;i++){
			if(a[i]!=b[i])
				return false;
		}
		return true;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		
		int w[] = {1, 2, 3};
		int x[] = {4, 5, 6};
		int y[] = {1, 2, 3};
		int z[] = {1, 3, 2};

		System.out.println("w==>"+Arrays.toString(w));
		System.out.println("x==>"+Arrays.toString(x));
		System.out.println("y==>"+Arrays.toString(y));
		System.out.println("z==>"+Arrays.toString(z));

		Arrays.sort(w);
		Arrays.sort(x);
		Arrays.sort(y);
		Arrays.sort(z);

		System.out.println("w==x : "+Demo.myEqual(w,x));//false
		System.out.println("w==y : "+Demo.myEqual(w,y));//true
		System.out.println("w==z : "+Demo.myEqual(w,z));//true
	}
}

output:
-------
w==>[1, 2, 3]
x==>[4, 5, 6]
y==>[1, 2, 3]
z==>[1, 3, 2]
w==x : false
w==y : true
w==z : true

case3: by using predefined methods
----------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		
		int w[] = {1, 2, 3};
		int x[] = {4, 5, 6};
		int y[] = {1, 2, 3};
		int z[] = {1, 3, 2};

		System.out.println("w==>"+Arrays.toString(w));
		System.out.println("x==>"+Arrays.toString(x));
		System.out.println("y==>"+Arrays.toString(y));
		System.out.println("z==>"+Arrays.toString(z));

		System.out.println("w==x : "+Arrays.equals(w,x));//false
		System.out.println("w==y : "+Arrays.equals(w,y));//true
		System.out.println("w==z : "+Arrays.equals(w,z));//false
	}
}

output:
-------
w==>[1, 2, 3]
x==>[4, 5, 6]
y==>[1, 2, 3]
z==>[1, 3, 2]
w==x : false
w==y : true
w==z : false

case4: by using predefined methods and ignoring order
-----------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		
		int w[] = {1, 2, 3};
		int x[] = {4, 5, 6};
		int y[] = {1, 2, 3};
		int z[] = {1, 3, 2};

		System.out.println("w==>"+Arrays.toString(w));
		System.out.println("x==>"+Arrays.toString(x));
		System.out.println("y==>"+Arrays.toString(y));
		System.out.println("z==>"+Arrays.toString(z));

		Arrays.sort(w);
		Arrays.sort(x);
		Arrays.sort(y);
		Arrays.sort(z);

		System.out.println("w==x : "+Arrays.equals(w,x));//false
		System.out.println("w==y : "+Arrays.equals(w,y));//true
		System.out.println("w==z : "+Arrays.equals(w,z));//true
	}
}

output:
-------
w==>[1, 2, 3]
x==>[4, 5, 6]
y==>[1, 2, 3]
z==>[1, 3, 2]
w==x : false
w==y : true
w==z : true


Inserting, Deleting and Updating Array Elements:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Inserting an element into the array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
case1: inserting an element in to the first location
case2: inserting an element in to the last location
case3: inserting an element in to specified location

deleting an element from an array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
case1: deleting an element from first location
case2: deleting an element from last location
case3: deleting an element from given location
case4: deleting all elements from an array
case5: deleting specified element from an array
case6: deleting specified element from an array first and second occurrence
case7: deleting specified element from an array in all occurrences

updating element in an array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
case1: updating an element present at given location.
case2: updating the given element with new element first occurrence.
case3: updating the given element with new element first and second occurrence.
case4: updating the given element with new element in all occurrences.



Inserting an element into the array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The following are the various possibilities to insert an element into an array

case1: inserting an element in to the first location
case2: inserting an element in to the last location
case3: inserting an element in to specified location

case1: inserting an element in to the first location
----------------------------------------------------
import java.util.*;

class Demo
{
	static int[] insertAtFirst(int a[], int element){
		int i,b[] = new int[a.length+1];
		b[0] = element;
		for(i=0;i<a.length;i++){
			b[i+1]=a[i];
		}
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {44, 66, 77};
		System.out.println(Arrays.toString(a));//[44, 66, 77]
		a=Demo.insertAtFirst(a,33);
		System.out.println(Arrays.toString(a));//[33, 44, 66, 77]
	}
}

output:
-------
[44, 66, 77]
[33, 44, 66, 77]

case2: inserting an element in to the last location
---------------------------------------------------
import java.util.*;

class Demo
{
	static int[] insertAtLast(int a[], int element){
		int i,b[] = new int[a.length+1];
		for(i=0;i<a.length;i++){
			b[i]=a[i];
		}
		b[i]=element;
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {44, 66, 77};
		System.out.println(Arrays.toString(a));//[44, 66, 77]
		a=Demo.insertAtLast(a,88);
		System.out.println(Arrays.toString(a));//[44, 66, 77, 88]
		a=Demo.insertAtLast(a,99);
		System.out.println(Arrays.toString(a));//[44, 66, 77, 88, 99]
	}
}

output:
-------
[44, 66, 77]
[44, 66, 77, 88]
[44, 66, 77, 88, 99]

case3: inserting an element in to specified location
----------------------------------------------------
import java.util.*;

class Demo
{
	static int[] insertAtLoc(int a[], int element,int location){
		int i,b[] = new int[a.length+1];
		for(i=0;i<location;i++){
			b[i]=a[i];
		}
		b[location]=element;
		for(;i<a.length;i++){
			b[i+1]=a[i];
		}
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {44, 66, 77};
		System.out.println(Arrays.toString(a));//[44, 66, 77]
		a=Demo.insertAtLoc(a,55,1);
		System.out.println(Arrays.toString(a));//[44, 55, 66, 77]
	}
}

output:
-------
[44, 66, 77]
[44, 55, 66, 77]

deleting an element from an array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
case1: deleting an element from first location
case2: deleting an element from last location
case3: deleting an element from given location
case4: deleting all elements from an array
case5: deleting specified element from an array
case6: deleting specified element from an array first and second occurrence
case7: deleting specified element from an array in all occurrences

case1: deleting an element from first location
----------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteatFirstLocation(int a[]){
		int i,b[]=new int[a.length-1];
		for(i=0;i<a.length-1;i++)
		{
			b[i]=a[i+1];
		}
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {44, 66, 77};
		System.out.println(Arrays.toString(a));//[44, 66, 77]
		a=Demo.deleteatFirstLocation(a);
		System.out.println(Arrays.toString(a));//[66, 77]
	}
}

output:
-------
[44, 66, 77]
[66, 77]

case2: deleting an element from last location
---------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteatLastLocation(int a[]){
		int i,b[]=new int[a.length-1];
		for(i=0;i<a.length-1;i++)
		{
			b[i]=a[i];
		}
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {44, 66, 77};
		System.out.println(Arrays.toString(a));//[44, 66, 77]
		a=Demo.deleteatLastLocation(a);
		System.out.println(Arrays.toString(a));//[44, 66]
	}
}

output:
-------
[44, 66, 77]
[44, 66]

case3: deleting an element from given location
----------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteatFromLocation(int a[],int location){
		int i,k,b[]=new int[a.length-1];
		for(i=0,k=0;i<a.length;i++)
		{
			if(i==location)
				continue;
			else
				b[k++]=a[i];
		}
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 13, 14, 15, 16};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 13, 14, 15, 16]
		a=Demo.deleteatFromLocation(a,2);
		System.out.println(Arrays.toString(a));//[10, 11, 13, 14, 15, 16]
	}
}

output:
-------
[10, 11, 12, 13, 14, 15, 16]
[10, 11, 13, 14, 15, 16]

case4: deleting all elements from an array
------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteAll(int a[]){
		int b[] = new int[0];
		return b;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 13, 14, 15, 16};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 13, 14, 15, 16]
		a=Demo.deleteAll(a);
		System.out.println(Arrays.toString(a));//[]
	}
}

output:
-------
[10, 11, 12, 13, 14, 15, 16]
[]

case5: deleting specified element from an array
-----------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteElement(int a[], int element){
		int index=-1,i,k;
		for(i=0;i<a.length;i++){
			if(a[i]==element){
				index=i;
				break;
			}
		}
		if(index!=-1){
			int b[] = new int[a.length-1];
			for(i=0,k=0;i<a.length;i++){
				if(i==index)
					continue;
				else
					b[k++] = a[i];
			}
			return b;
		}
		else
			return a;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		a=Demo.deleteElement(a,11);
		System.out.println(Arrays.toString(a));//[10, 12, 11, 14, 11, 16, 11]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 12, 11, 14, 11, 16, 11]

case6: deleting specified element from an array first and second occurrence
---------------------------------------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteatFromLocation(int a[],int location){
		int i,k,b[]=new int[a.length-1];
		for(i=0,k=0;i<a.length;i++)
		{
			if(i==location)
				continue;
			else
				b[k++]=a[i];
		}
		return b;
	}
	static int[] deleteElementFromFirstAndSecondOcc(int a[], int element){
		int index=-1,i,k,c=0;
		for(i=0;i<a.length;i++){
			if(a[i]==element){
				c++;
				a=deleteatFromLocation(a,i);
				if(c==2)
					break;
			}
		}
		return a;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		a=Demo.deleteElementFromFirstAndSecondOcc(a,11);
		System.out.println(Arrays.toString(a));//[10, 12, 14, 11, 16, 11]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 12, 14, 16, 11]

case7: deleting specified element from an array in all occurrences
-------------------------------------------------------------------
import java.util.*;

class Demo
{
	static int[] deleteatFromLocation(int a[],int location){
		int i,k,b[]=new int[a.length-1];
		for(i=0,k=0;i<a.length;i++)
		{
			if(i==location)
				continue;
			else
				b[k++]=a[i];
		}
		return b;
	}
	static int[] deleteAllOcc(int a[], int element){
		int i;
		for(i=0;i<a.length;i++){
			if(a[i]==element){
				a=deleteatFromLocation(a,i);
			}
		}
		return a;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		a=Demo.deleteAllOcc(a,11);
		System.out.println(Arrays.toString(a));//[10, 12, 14, 16]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 12, 14, 16]

updating element in an array:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
case1: updating an element present at given location.
case2: updating the given element with new element first occurrence.
case3: updating the given element with new element first and second occurrence.
case4: updating the given element with new element in all occurrences.

case1: updating an element present at given location.
-----------------------------------------------------
import java.util.*;

class Demo
{
	static void updateAtLoc(int a[],int loc,int ele){
		a[loc] = ele;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		Demo.updateAtLoc(a,1,999);
		System.out.println(Arrays.toString(a));//[10, 999, 12, 11, 14, 11, 16, 11]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 999, 12, 11, 14, 11, 16, 11]

case2: updating the given element with new element first occurrence.
--------------------------------------------------------------------
import java.util.*;

class Demo
{
	static void updateElementFirst(int a[],int olde,int newe){
		for(int i=0;i<a.length;i++){
			if(a[i]==olde){
				a[i]=newe;
				break;
			}
		}
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		Demo.updateElementFirst(a,11,888);
		System.out.println(Arrays.toString(a));//[10, 888, 12, 11, 14, 11, 16, 11]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 888, 12, 11, 14, 11, 16, 11]

case3: updating the given element with new element first and second occurrence.
-------------------------------------------------------------------------------
import java.util.*;

class Demo
{
	static void updateElementFirstAndSecond(int a[],int olde,int newe){
		int c=0;
		for(int i=0;i<a.length;i++){
			if(a[i]==olde){
				c++;
				a[i]=newe;
				if(c==2)
					break;
			}
		}
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		Demo.updateElementFirstAndSecond(a,11,888);
		System.out.println(Arrays.toString(a));//[10, 888, 12, 11, 14, 11, 16, 11]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 888, 12, 888, 14, 11, 16, 11]

case4: updating the given element with new element in all occurrences.
----------------------------------------------------------------------
import java.util.*;

class Demo
{
	static void updateElementAllOcc(int a[],int olde,int newe){
		for(int i=0;i<a.length;i++){
			if(a[i]==olde){
				a[i]=newe;
			}
		}
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {10, 11, 12, 11, 14, 11, 16, 11};
		System.out.println(Arrays.toString(a));//[10, 11, 12, 11, 14, 11, 16, 11]
		Demo.updateElementAllOcc(a,11,888);
		System.out.println(Arrays.toString(a));//[10, 888, 12, 888, 14, 888, 16, 888]
	}
}

output:
-------
[10, 11, 12, 11, 14, 11, 16, 11]
[10, 888, 12, 888, 14, 888, 16, 888]


String Data Structure:-
~~~~~~~~~~~~~~~~~~~~~~
01. Introduction to Strings
02. Mutablitity and Immutablity
03. Heap and SCP memory areas
04. String class constructors and methods
05. StringBuffer class constructors and methods
06. StringBuilder class constructors and methods
07. StringBuffer vs StringBuilder
08. StringTokenizer
09. Programs on String
10. Programs on StringBuffer and StringBuilder
11. Progrmas on StringTokenizer
12. Regular Expressions and its applications

Introduction:
-------------
1) 99% of data in any application is string only.

Ex:
---
	voter management system

	vid
	name
	fname
	mname
	address
	emailid
	mbl
	zipcode
	dist
	state
	etc

	name,fname,mname,address,emailid,dist,state etc

2) string is an object.
3) string is a collection or group of characters.
4) in java strings are divided into the following four groups.

	1. String
	2. StringBuffer
	3. StringBuilder
	4. StringTokenizer

5) all these objects are almost same with small differences.

	String      ----> java.lang.String
	StringBuffer ---> java.lang.StringBuffer
	StringBuilder --> java.lang.StringBuilder
	StringTokenizer-> java.util.StringTokenizer

String Constant Pool and SCP memory areas w.r.t Strings:-
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Once if a string object is created, java creates that string obj in string constant pool, the main advantage of this approach is reusability.

Ex:
---
	String s1 = "abc";
	String s2 = "abc";
	String s3 = "abc";

	no. of string objects ----> 1

Ex:
---
	String s1 = new String("abc");
	String s2 = new String("abc");
	String s3 = new String("abc");

	no. of string objects -----> 3(heap) +1(scp) = 4 objects


String
------
constructors:
-------------
1) String()              ----> to create an empty string obj
2) String(StringLiteral) ----> it create a string obj with given literal
3) String(char[]) -----------> create str obj with given char[]
4) String(char[],int,int) ---> create str obj with given char[] from start to num of ch
5) String(int[],int,int) ----> create str obj with given int[] from start to num of int
6) String(byte[]) -----------> create str obj with byte[]
7) String(StringBuffer) -----> create str obj with string buffer obj
8) String(StringBuilder) ----> create str obj with string builder obj

methods:
--------
int length() ---> returns num of char present in the given string
boolean isEmpty(); --> return true if the given contains empty literal
char charAt(int index); --> return char present at given index
boolean startsWith(str); ---> returns true if given str starts with sub-str
boolean endsWith(str); ---> returns true if given str ends with sub-str
char[] toCharArray();---> converts given str into char[]
byte[] getBytes(); ----> converts given str into byte[]
boolean equals(str); 
boolean equalsIgnoreCase(str); 
int indexOf(char) ---> returns index of first occurrent of that char
int lastIndexOf(char) ---> returns index of last occurrent of that char
int compareTo(Str) ----> it compare two str based on ascii values
int compareToIgnoreCase(Str) ----> it compare two str based on ascii values
String substring(begin_index); 
String substring(begin_index,end_index); 
boolean contains(str) 
String concat(str) => it is used to concatenation of two strings
String replace(old_c,new_c) ==> it replaces old char with new char
String toUpperCase() ===> it converts each char into upper case
String toLowerCase() ===> it converts each char into lower case
String[] split(delimiter) ===> based on given delimiter it split the given string

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		System.out.println("abc".equals("def"));//false
		System.out.println("abc".equals("abc"));//true
		System.out.println("abc".equals("ABC"));//false
		System.out.println("abc".equalsIgnoreCase("ABC"));//true
	}
}

output:
-------
false
true
false
true

Ex:
---
class Test 
{
	static String toSwapCase(String s){
		StringBuffer sb = new StringBuffer();
		for(int i=0;i<s.length();i++)
		{	
			if(s.charAt(i)>='a' && s.charAt(i)<='z')
				sb.append((char)(s.charAt(i)-32));
			if(s.charAt(i)>='A' && s.charAt(i)<='Z')
				sb.append((char)(s.charAt(i)+32));
		}
		return sb.toString();
	}
	public static void main(String[] args) 
	{
		System.out.println("abc".toUpperCase());//ABC
		System.out.println("ABC".toLowerCase());//abc
		System.out.println("WeLcOmE".toLowerCase());//welcome
		System.out.println("WeLcOmE".toUpperCase());//WELCOME
		System.out.println(toSwapCase("WeLcOmE"));//wElCoMe
	}
}

output:
-------
ABC
abc
welcome
WELCOME
wElCoMe

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		System.out.println("java is very easy".startsWith("python"));//false
		System.out.println("java is very easy".startsWith("java"));//true

		System.out.println("java is very easy".endsWith("easy"));//true
		System.out.println("java is very easy".endsWith("difficult"));//false
	}
}

output:
-------
false
true
true
false


String Handling Programs:
-------------------------
01) Print char and corresponding index value?
---------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			System.out.println(i+" ====> "+s.charAt(i));
		}
	}
}

output:
-------
welcome
0 ====> w
1 ====> e
2 ====> l
3 ====> c
4 ====> o
5 ====> m
6 ====> e

02) Print char and corresponding index value which are present at even indexed loc?
------------------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			if(i%2==0)
				System.out.println(i+" ====> "+s.charAt(i));
		}
	}
}

output:
-------
welcome
0 ====> w
2 ====> l
4 ====> o
6 ====> e

03) Print char and corresponding index value which are present at odd indexed loc?
------------------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			if(i%2!=0)
				System.out.println(i+" ====> "+s.charAt(i));
		}
	}
}

output:
-------
welcome
1 ====> e
3 ====> c
5 ====> m

04) print vowels present in the given string
--------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			char temp = s.charAt(i);
			if(temp=='a'||temp=='e'||temp=='i'||temp=='o'||temp=='u')
				System.out.println(s.charAt(i));
		}
	}
}

output:
-------
welcome
e
o
e

05) print consonants present in the given string
-------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			char temp = s.charAt(i);
			if(!(temp=='a'||temp=='e'||temp=='i'||temp=='o'||temp=='u'))
				System.out.println(s.charAt(i));
		}
	}
}

output:
-------
welcome
w
l
c
m

06) count number of vowels in string
07) count number of consonants in string

08) sort all characters present in the given string in asc order?
-----------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("welcome");
		char ch[] = s1.toCharArray();
		
		Arrays.sort(ch);
		String s2 = new String(ch);

		System.out.println(s1);
		System.out.println(s2);
	}
}

output:
-------
welcome
ceelmow

09) sort all characters present in the given string in desc order?
-----------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("welcome");
		String s2 = "";
		char ch[] = s1.toCharArray();
		
		Arrays.sort(ch);
		
		for(int i=ch.length-1;i>=0;i--){
			s2=s2+ch[i];
		}

		System.out.println(s1);
		System.out.println(s2);
	}
}

output:
-------
welcome
womleec


10) check whether two strings are anagrams or not?
--------------------------------------------------
"acb", "abc" ---> true

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("race");
		String s2 = new String("care");
		String s3 = new String("cary");

		char ch1[] = s1.toCharArray();
		char ch2[] = s2.toCharArray();
		char ch3[] = s3.toCharArray();

		Arrays.sort(ch1);
		Arrays.sort(ch2);
		Arrays.sort(ch3);

		System.out.println(Arrays.equals(ch1,ch2));
		System.out.println(Arrays.equals(ch1,ch3));
	}
}

output:
-------
true
false


https://us06web.zoom.us/meeting/register/tZAvcO-opzguGNaWtfrsprIdPPZ10KZALTcr

java.lang.StringBuffer:
-----------------------
=> it is a group of characters.
=> it is mutable object, i.e. modifications are allowed.
=> 1.0 version (legacy)
=> allow only single thread to operate (single thread based application)
=> storing results in the university result db. (StringBuffer).
=> every method is synchronozed.

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome ");
		s.concat("python");
		System.out.println(s);//welcome
	}
}

output:
-------
welcome

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome ");
		s=s.concat("python");
		System.out.println(s);//welcome python
	}
}

output:
-------
welcome python

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb = new StringBuffer("welcome ");
		sb.append("java");
		System.out.println(sb);//welcome java
	}
}

output:
-------
welcome java

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuilder sb = new StringBuilder("welcome ");
		sb.append("prakash");
		System.out.println(sb);//welcome prakash
	}
}

output:
-------
welcome prakash

java.lang.StringBuilder:
-----------------------
=> it is a group of characters.
=> it is mutable object, i.e. modifications are allowed.
=> 1.5 version (not legacy)
=> allow multiple threads to operate (multi threaded based application)
=> retriving results from the university result db. (StringBuilder).
=> every method is non-synchronozed.

Ex:
---
	synchronized void insertData(123,99){
		---------------
		---------------
	}

	void ReadData(123){
		---------------
		---------------
	}

all the methods and constructors are same in StringBuffer and StringBuilder

construction of string buffer objects:-
--------------------------------------
1) StringBuffer(); -------> an empty string buffer obj with 16 as default capacity
2) StringBuffer(int); ----> an empty sb obj with given capacity
3) StringBuffer(str); ----> a sb obj with given string (capacity: 16+len of str)

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb1 = new StringBuffer();
		StringBuffer sb2 = new StringBuffer(100);
		StringBuffer sb3 = new StringBuffer("abc");
		System.out.println(sb1.capacity());//16
		System.out.println(sb2.capacity());//100
		System.out.println(sb3.capacity());//16+3=19
	}
}

output:
-------
16
100
19

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb = new StringBuffer();
		
		sb.append("abcdefghijklmnop");
		System.out.println(sb);//abcdefghijklmnop
		System.out.println(sb.capacity());//16

		sb.append("q");
		System.out.println(sb);//abcdefghijklmnopq
		//new capcaity = (old capacity+1)*2
		System.out.println(sb.capacity());//(16+1)*2=17*2=34
	}
}

output:
-------
abcdefghijklmnop
16
abcdefghijklmnopq
34

methods:
--------
int length()         -----------> return number of characters present
int capacity()         ---------> return max number of characters are allowed
void setLength(int) -        ---> set the string buffer length
void trimToSize() -        -----> remove unwanted spaces
void ensureCapacity(int)     ---> to increase capacity of sb
char charAt(int)      ----------> return char present at the given location
void setCharAt(int,char)     ---> it replaces char present given location with new char
StringBuffer append(obj)     ---> it inserts the given obj at the end of sb
StringBuffer insert(int,obj) ---> it inserts the given obj at the given location in sb
StringBuffer delete(start,end) -> it removes characters present from start to end-1
StringBuffer reverse() ---------> it reverse the content of sb

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb = new StringBuffer("abcdefg");
		System.out.println(sb);//abcdefg
		System.out.println(sb.charAt(0));//a
		System.out.println(sb.charAt(1));//b
		sb.setCharAt(1,'W');
		System.out.println(sb);//aWcdefg
		sb.deleteCharAt(3);
		System.out.println(sb);//aWcefg
	}
}

output:
-------
abcdefg
a
b
aWcdefg
aWcefg

Ex:
---
class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb = new StringBuffer("welcome ");
		System.out.println(sb);//welcome
		sb.append("java ");
		sb.append(18);
		sb.append(" and ");
		sb.append(3.9);
		System.out.println(sb);//welcome java 18 and 3.9
		sb.insert(8,"to ");
		sb.insert(23,"python ");
		System.out.println(sb);//welcome to java 18 and python 3.9
		sb.delete(11,23);
		System.out.println(sb);//welcome to python 3.9
	}
}

output:
-------
welcome
welcome java 18 and 3.9
welcome to java 18 and python 3.9
welcome to python 3.9

java.util.StringTokenizer
-------------------------
=> it is an utility provided by java.util pacakge.
=> it divides the string into tokens

"java is very easy" -----> ["java","is","very","easy"]
"19-12-2022" ------------> ["19","12","2022"]
"05:51" -----------------> ["05","51"]

StringTokenizer st = new StringTokenizer(string,delimiter); //defaulat del is ' '

int countTokens() --------> return number of tokens
boolean hasMoreTokens() --> return true if there is token
String nextToken() -------> return current token and transfer the control to next token


Ex: reverse the given string
----------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		System.out.println("Original String="+s);
		System.out.println("Reversed String="+new StringBuffer(s).reverse());
	}
}

output:
-------
Enter any string:
prakash
Original String=prakash
Reversed String=hsakarp

Ex: paliandrome string
----------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		String ss = new StringBuffer(s).reverse().toString();

		System.out.println(s.equals(ss));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter any string:
liril
true

C:\prakashclasses>java Test
Enter any string:
madam
true

C:\prakashclasses>java Test
Enter any string:
abcd
false

C:\prakashclasses>java Test
Enter any string:
123
false

C:\prakashclasses>java Test
Enter any string:
121
true

Ex: read a string and convert into words
----------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens()){
			System.out.println(st.nextToken());
		}
	}
}

output:
-------
Enter any string:
java is very very easy to understand.
java
is
very
very
easy
to
understand.

Ex: read a string seperated by , and fetch data one by one
-----------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		StringTokenizer st = new StringTokenizer(s,",");
		while(st.hasMoreTokens()){
			System.out.println(st.nextToken());
		}
	}
}

output:
-------
Enter any string:
10,20,30,40,50
10
20
30
40
50

Ex: read a sentence and reverse the total given sentence
--------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer(s);
		sb.reverse();
		System.out.println(sb);
	}
}

output:
-------
Enter any string:
java is very very difficult while learning
gninrael elihw tluciffid yrev yrev si avaj

Ex: read a string and reverse and individual words
--------------------------------------------------
abc def ijk mno wxyz ----> cba fed kji onm zyxw

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);

		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java is very easy for coding.
avaj si yrev ysae rof .gnidoc

Ex: read a string and reverse alternative words
-----------------------------------------------
abc def ijk mno wxyz ----> abc fed ijk onm wxyz
abc def ijk mno wxyz ----> cba def kji mno zyxw

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		int i=0;
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(i%2==0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
			i++;
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
abc def ijk pqrs xyz
abc fed ijk srqp xyz

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		int i=0;
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(i%2!=0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
			i++;
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
abc def ijk pqrs xyz
cba def kji pqrs zyx

Ex: read a string and reverse even length words
-----------------------------------------------
java was very easy programming language when compared with other

avaj was yrev ysae programming egaugnal nehw derapmoc htiw other


Ex:
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(ss.length()%2!=0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
avaj was yrev ysae programming egaugnal nehw derapmoc htiw other

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(ss.length()%2==0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
java saw very easy gnimmargorp language when compared with rehto

Ex: read a string and convert every word first char into caps
--------------------------------------------------------------
java was very easy programming language when compared with other
Java Was Very Easy Programming Language When Compared With Other

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			
			sb.append(ss.substring(0,1).toUpperCase()+ss.substring(1));
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
Java Was Very Easy Programming Language When Compared With Other

Ex: read a string and convert every word first and last char into caps
-----------------------------------------------------------------------
java was very easy programming language when compared with other
JavA WaS VerY EasY ProgramminG LanguagE WheN CompareD WitH OtheR

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int n;
		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			n = ss.length();
			sb.append(ss.substring(0,1).toUpperCase()+ss.substring(1,n-1)+ss.substring(n-1,n).toUpperCase());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}


output:
-------
Enter any string:
java was very easy programming language when compared with other
JavA WaS VerY EasY ProgramminG LanguagE WheN CompareD WitH OtheR


Ex: read a string and except first and last char remaining into upper case
--------------------------------------------------------------------------
java was very easy programming language when compared with other
JavA WaS VerY EasY ProgramminG LanguagE WheN CompareD WitH OtheR

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int n;
		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			n = ss.length();
			sb.append(ss.substring(0,1)+ss.substring(1,n-1).toUpperCase()+ss.substring(n-1,n));
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
jAVa wAs vERy eASy pROGRAMMINg lANGUAGe wHEn cOMPAREd wITh oTHEr



content comparision and reference comparision:
----------------------------------------------
primitives and objects

primitives -----> == operator for content comparision

objects -------->
				
				== reference comparision
				.equals() reference comparision

Ex:
---
import java.util.*;

class Demo{

}
class Test 
{
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		Demo d3;
		d3=d1;

		System.out.println(d1==d2);//false
		System.out.println(d1.equals(d2));//false

		System.out.println(d1==d3);//true
		System.out.println(d1.equals(d3));//true
	}
}

output:
-------
false
false
true
true


String objects -------->
				
				== reference comparision
				.equals() content comparision

.equals() method present in java.lang.Object class, java.lang.String has overriden this method for content comparision.

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("abc");
		String s2 = new String("abc");
		String s3 = s1;

		System.out.println(s1==s2);//false
		System.out.println(s1.equals(s2));//true

		System.out.println(s1==s3);//true
		System.out.println(s1.equals(s3));//true
	}
}

output:
-------
false
true
true
true

StringBuffer objects -------->
				
				== reference comparision
				.equals() reference comparision

.equals() method present in java.lang.Object class, java.lang.String has overriden this method for content comparision and java.lang.StringBuffer has not overriden this method, hence for StringBuffer objects == and .equals() are same.

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		StringBuffer sb1 = new StringBuffer("abc");
		StringBuffer sb2 = new StringBuffer("abc");
		StringBuffer sb3 = sb1;

		System.out.println(sb1==sb2);//false
		System.out.println(sb1.equals(sb2));//false

		System.out.println(sb1==sb3);//true
		System.out.println(sb1.equals(sb3));//true
	}
}

output:
-------
false
false
true
true

SCP and Heap Area
-----------------
Object creation in SCP is always optional, if an object is already existed, it wn't create any new object. In the case new keyword every time a new object will be created in heap area.

Ex1:
----
String s = new String("prakash");

heap ---> 1
scp ----> 1
total --> 2

Ex2:
----
String s = "prakash";

heap ---> 0
scp ----> 1
total --> 1

Ex3:
----
String s1 = new String("abc");
String s2 = new String("abc");
String s3 = "abc";
String s4 = "abc";

heap ---> 2
scp ----> 1
total --> 3

Ex4:
----
String s = new String("abc");
s.concat("pqr");
s=s.concat("wxyz");

heap ---> 3
scp ----> 3
total --> 6

Ex5:
----
String s1 = new String("spring");
s1.concat("fall");
String s2 = s1.concat("winter");
s2.concat("summer");

heap ---> 4
scp ----> 4
total --> 8


Ex6:
----
String s1 = "abc";
String s2 = s1.toUpperCase();
String s3 = s1.toLowerCase();

s1==s2 ----> false
s1==s3 ----> true

scp ----> 2
heap ---> 0
total --> 2

Ex7:
----
String s1 = "abc";
String s2 = s1.toString();

s1==s2 ----> true

heap ----> 0
scp -----> 1
total ---> 1

Ex8:
----
String s1 = new String("abc");
String s2 = s1.toString();

s1==s2 ----> false

heap ----> 1
scp -----> 1
total ---> 2

Note:
-----
1) because of runtime operation if there is a change in the content with those changes a new object will be created only on heap area but not on scp area.

2) if there is no change in the content no new object will be created the same obj will be reused. this rule is applicable whether the obj is present in SCP or HEAP.

Ex9:
----
		String s1 = new String("abc");
		String s2 = s1.toString();
		String s3 = s1.toUpperCase();
		String s4 = s1.toLowerCase();
		String s5 = s1.toUpperCase();
		String s6 = s3.toLowerCase();

heap ----> 4
scp -----> 1
total ---> 5

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("abc");
		String s2 = s1.toString();
		String s3 = s1.toUpperCase();
		String s4 = s1.toLowerCase();
		String s5 = s1.toUpperCase();
		String s6 = s3.toLowerCase();
		System.out.println(s3==s5);//false
		System.out.println(s1==s6);//false
		System.out.println(s1==s2);//true
		System.out.println(s1==s4);//true
	}
}

Ex10:
-----
String s1 = new String("i love my india");
String s2 = new String("i love my india");
System.out.println(s1==s2);
String s3 = "i love my india";
System.out.println(s1==s3);
String s4 = "i love my india";
System.out.println(s3==s4);
String s5 = "i love "+"my india";
System.out.println(s4==s5);
String s6 = "i love ";
String s7 = s6+"my india";
System.out.println(s4==s7);
final String s8 = "i love ";
String s9 = s8+"my india";
System.out.println(s4==s9); 

heap ------> 3
scp -------> 3
total -----> 6

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("i love my india");
		String s2 = new String("i love my india");
		System.out.println(s1==s2);//false
		String s3 = "i love my india";
		System.out.println(s1==s3);//false
		String s4 = "i love my india";
		System.out.println(s3==s4);//true
		String s5 = "i love "+"my india";
		System.out.println(s4==s5);//true
		String s6 = "i love ";
		String s7 = s6+"my india";
		System.out.println(s4==s7);//false
		final String s8 = "i love ";
		String s9 = s8+"my india";
		System.out.println(s4==s9);//true
	}
}

Interning of String objects:
----------------------------
Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("abc");
		String s2 = s1.intern();
		String s3 = "abc";

		System.out.println(s2==s1);//false
		System.out.println(s2==s3);//true
	}
}

Ex:
---
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("abc");
		String s2 = s1.concat("def");
		String s3 = s2.intern();
		String s4 = "abcdef";

		System.out.println(s3==s4);//true
	}
}

regular expressions and applications
------------------------------------
a group of strings according to particualr pattern or format is called as re

steps to regular expression objects
-----------------------------------
1) import java.util.regex.*;
2) pattern object -----> format of data
3) matcher object -----> target string or input

predefined character classes:
-----------------------------
\s 		space character
\S 		except space character
\d 		digit
\D 		except digit
\w 		word character (a-z,A-Z,0-9)
\W 		except word character


Ex1:
----
import java.util.regex.*;

class Test 
{
	public static void main(String[] args)
	{
		Pattern p = Pattern.compile("\\W");//pattern obj
		Matcher m = p.matcher("abc$123#iJk^456*pQr wXYz");//target str
		int c=0;
		while(m.find()){
			c++;
		}
		System.out.println(c);
	}
}

userdefined character classes:
------------------------------
[abc] 		either 'a' or 'b' or 'c'
[^abc]		except either 'a' or 'b' or 'c'
[0-9]		all digits
[^0-9]		except digits
[a-z]		only lower case alphabets
[^a-z]		except lower case alphabets
[A-Z]		only upper case alphabets
[^A-Z]		except upper case alphabets
[a-zA-Z]	both lower and upper case alphabets
[a-zA-Z0-9]	word characer
[^a-zA-Z]	except lower and upper case alphabets
[^a-zA-Z0-9]except word characer


Ex2:
----
import java.util.regex.*;

class Test 
{
	public static void main(String[] args)
	{
		Pattern p = Pattern.compile("[0-2]");//pattern obj
		Matcher m = p.matcher("abc$123#iJk^456*pQr wXYz");//target str
		int c=0;
		while(m.find()){
			c++;
		}
		System.out.println(c);
	}
}

Ex3:
----
import java.util.regex.*;

class Test 
{
	public static void main(String[] args)
	{
		Pattern p = Pattern.compile("[a-z]");//pattern obj
		Matcher m = p.matcher("abc$123#iJk^456*pQr wXYz");//target str
		int c=0;
		while(m.find()){
			c++;
		}
		System.out.println(c);
	}
}

Ex4:
----
import java.util.regex.*;

class Test 
{
	public static void main(String[] args)
	{
		Pattern p = Pattern.compile("[^a-zA-Z0-9 ]");//pattern obj
		Matcher m = p.matcher("abc$123#iJk^456*pQr wXYz");//target str
		int c=0;
		while(m.find()){
			c++;
		}
		System.out.println(c);
	}
}

quantifiers:
------------
a  			exactly one 'a'
a+ 			one or more 'a's
a* 			zero or more characters
a? 			zero or one character
a{m} 		exactly 'm' number of a's
a{m,n} 		min 'm' number of a's and max 'n' number of a's

Ex5:
----
import java.util.regex.*;

class Test 
{
	public static void main(String[] args)
	{
		Pattern p = Pattern.compile("a{3,5}");//pattern obj
		Matcher m = p.matcher("abaabaaabaaaabaaaaabaaaaaab");//target str
		while(m.find()){
			System.out.println(m.start()+"===>"+m.end()+"===>"+m.group());
		}
	}
}

01. Impl prg to read str and print char and corresponding index value.
-----------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			System.out.println(i+" ====> "+s.charAt(i));
		}
	}
}

output:
-------
welcome
0 ====> w
1 ====> e
2 ====> l
3 ====> c
4 ====> o
5 ====> m
6 ====> e

02. Impl prg to read str and print chars present at even/odd index values.
--------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			if(i%2==0)
				System.out.println(i+" ====> "+s.charAt(i));
		}
	}
}

output:
-------
welcome
0 ====> w
2 ====> l
4 ====> o
6 ====> e

03. Impl prg to print vowels/consonants present in the given str.
-----------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		for(int i=0;i<s.length();i++){
			char temp = s.charAt(i);
			if(temp=='a'||temp=='e'||temp=='i'||temp=='o'||temp=='u')
				System.out.println(s.charAt(i));
		}
	}
}

output:
-------
welcome
e
o
e

04. Impl prg to count numbers of vowels/consonants present in the given str.
----------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("welcome");
		                     //0123456
		System.out.println(s);
		int count=0;
		for(int i=0;i<s.length();i++){
			char temp = s.charAt(i);
			if(temp=='a'||temp=='e'||temp=='i'||temp=='o'||temp=='u')
				count++;
		}
		System.out.println(count);
	}
}

output:
-------
3

05. Impl prg to sort all the characters in asc/desc order.
----------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("welcome");
		char ch[] = s1.toCharArray();
		
		Arrays.sort(ch);
		String s2 = new String(ch);

		System.out.println(s1);
		System.out.println(s2);
	}
}

output:
-------
welcome
ceelmow

06. Impl prg to check whether the given strs are anagrams or not.
-----------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s1 = new String("race");
		String s2 = new String("care");
		String s3 = new String("cary");

		char ch1[] = s1.toCharArray();
		char ch2[] = s2.toCharArray();
		char ch3[] = s3.toCharArray();

		Arrays.sort(ch1);
		Arrays.sort(ch2);
		Arrays.sort(ch3);

		System.out.println(Arrays.equals(ch1,ch2));
		System.out.println(Arrays.equals(ch1,ch3));
	}
}

output:
-------
true
false

07. Impl prg to check whether the given str is paliandrome or not.
------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		String ss = new StringBuffer(s).reverse().toString();

		System.out.println(s.equals(ss));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter any string:
liril
true

C:\prakashclasses>java Test
Enter any string:
madam
true

C:\prakashclasses>java Test
Enter any string:
abcd
false

C:\prakashclasses>java Test
Enter any string:
123
false

C:\prakashclasses>java Test
Enter any string:
121
true

08. Impl prg to check whether the given str is pangram or not.
--------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		String s = new String("the quick brown fox jumps over the lazy dog");
		boolean flag = true;          
		System.out.println(s);
		for(int i='a';i<='z';i++){
			if(s.indexOf(i)<0){
				flag = false;
				break;
			}
		}
		System.out.println(flag);
	}
}

output:
-------
C:\prakashclasses>java Test
abcdefghijklmnopqrstuvwxyz
true

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
abcdefghijklmnopqrsuvwxyz
false

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
the quick brown fox jumps over the lazy dog
true

09. Impl prg to divide the strings seperated by spaces/comma/-.
---------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		StringTokenizer st = new StringTokenizer(s," ");
		while(st.hasMoreTokens()){
			System.out.println(st.nextToken());
		}
	}
}

output:
-------
Enter any string:
java is very very easy to understand.
java
is
very
very
easy
to
understand.

10. Impl prg to reverse the entire sentence.
--------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer(s);
		sb.reverse();
		System.out.println(sb);
	}
}

output:
-------
Enter any string:
java is very very difficult while learning
gninrael elihw tluciffid yrev yrev si avaj

11. Impl prg to reverse individual words.
-----------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);

		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java is very easy for coding.
avaj si yrev ysae rof .gnidoc

12. Impl prg to reverse alternative words.
------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		int i=0;
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(i%2==0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
			i++;
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
abc def ijk pqrs xyz
abc fed ijk srqp xyz

13. Impl prg to reverse even/odd length words.
----------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			if(ss.length()%2!=0)
				sb.append(ss);
			else
				sb.append(new StringBuffer(ss).reverse());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
avaj was yrev ysae programming egaugnal nehw derapmoc htiw other

14. Impl prg to convert every word first char into caps.
--------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			
			sb.append(ss.substring(0,1).toUpperCase()+ss.substring(1));
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
Java Was Very Easy Programming Language When Compared With Other

15. Impl prg to convert every word first and last char into caps.
-----------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int n;
		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			n = ss.length();
			sb.append(ss.substring(0,1).toUpperCase()+ss.substring(1,n-1)+ss.substring(n-1,n).toUpperCase());
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}


output:
-------
Enter any string:
java was very easy programming language when compared with other
JavA WaS VerY EasY ProgramminG LanguagE WheN CompareD WitH OtheR

16. Impl prg to convert except first and last chars, remaining into upper case.
-------------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int n;
		System.out.println("Enter any string:");
		String s = obj.nextLine();
		StringBuffer sb = new StringBuffer();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String ss = st.nextToken();
			n = ss.length();
			sb.append(ss.substring(0,1)+ss.substring(1,n-1).toUpperCase()+ss.substring(n-1,n));
			sb.append(" ");
		}

		System.out.println(sb.toString());
	}
}

output:
-------
Enter any string:
java was very easy programming language when compared with other
jAVa wAs vERy eASy pROGRAMMINg lANGUAGe wHEn cOMPAREd wITh oTHEr

17. American board 
--------------------
Given a string, return the true if that can be typed using letters of alphabet on only one row's of American keyboard like the image below.

In the American keyboard:
=> the first row consists of the characters "qwertyuiop",
=> the second row consists of the characters "asdfghjkl", and
=> the third row consists of the characters "zxcvbnm".

Note: 
1. You may use one character in the keyboard more than once. 
2. You may assume the input string will only contain letters of alphabet.

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);//dad
		String s = obj.nextLine();
		String r1 = "qwertyuiop", r2 = "asdfghjkl", r3 = "zxcvbnm";
		int i,c1=0,c2=0,c3=0;
		for(i=0;i<s.length();i++){
			if(r1.contains(Character.toString(s.charAt(i))))
				c1++;
			else if(r2.contains(Character.toString(s.charAt(i))))
				c2++;
			else if(r3.contains(Character.toString(s.charAt(i))))
				c3++;
		}
		System.out.println(c1==s.length() || c2==s.length() || c3==s.length());
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
mom
false

C:\prakashclasses>java Test
dad
true

C:\prakashclasses>java Test
asdf
true

C:\prakashclasses>java Test
asdc
false

C:\prakashclasses>java Test
asde
false

C:\prakashclasses>java Test
pop
true

C:\prakashclasses>java Test
true
true

C:\prakashclasses>java Test
false
false

18. Rotate String 
-----------------
Given two strings s and ss, return true if and only if s can become ss after some number of shifts on s. A shift on s consists of moving the leftmost character of s to the rightmost position. 
For example, if s = "abcde", then it will be "bcdea" after one shift.

Ex:
---
	s = "abcde" and ss = "bcdea" ----> true

	abcde
	bcdea
	cdeab
	deabc
	eabcd

	abcdeabcde
Ex:
---

	s = "abcde" and ss = "bcdae" ----> false
	abcde
	bcdea
	cdeab
	deabc
	eabcd

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);//dad
		String s = obj.nextLine();
		String ss = obj.nextLine();
		System.out.println((s+s).contains(ss));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
abc
cba
false

C:\prakashclasses>java Test
abc
cab
true

C:\prakashclasses>java Test
abcde
bcdea
true

19. Impl prg to return middle char(s).
--------------------------------------
Ex:		abc ----> b
Ex:     abcd ---> bc

s.length()/2 ---> 3/2 --> 1 -----> s.charAt(mid)
s.length()/2 ---> 4/2 --> 1,2 ---> s.charAt(mid-1,mid)

import java.util.*;

class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);//dad
		String s = obj.nextLine();
		int n=s.length(),mid=n/2;
		if(n%2==0)
			System.out.println(s.charAt(mid-1)+""+s.charAt(mid));
		else
			System.out.println(s.charAt(mid));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
abc
b

C:\prakashclasses>java Test
abcd
bc

20. Impl prg to remove duplicate characters from the given str.
---------------------------------------------------------------
Ex:
---
	welcome ----> welcom
	abcabac ----> abc

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter source string:");
		String s = obj.nextLine();

		String ss = "";
		for(int i=0;i<s.length();i++){
			if(ss.indexOf(s.charAt(i))<0)
				ss=ss+s.charAt(i);
		}
		System.out.println(ss);
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter source string:
welcome
welcom

C:\prakashclasses>java Test
Enter source string:
abcababcab
abc

C:\prakashclasses>java Test
Enter source string:
prakash
praksh

21. Chess Board 
---------------
You are given coordinates, a string that represents the coordinates of a square of the chess board. bellow is the chess board for your reference.

Return True if the saquare is in white, and false if the square is in Black.

The coordinates will always represent a valid chess board square. The coordinates will always have the letter first, and the number second.

input ----------> a string
output ---------> true or false


xx ------> white ------> true
xx ------> black ------> false


import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter chess board address:");
		String s = obj.nextLine();

		int x = s.charAt(0)-96;
		int y = s.charAt(1);

		System.out.println(x%2!=y%2);
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter chess board address:
a1
false

C:\prakashclasses>java Test
Enter chess board address:
a2
true

C:\prakashclasses>java Test
Enter chess board address:
f4
false

C:\prakashclasses>java Test
Enter chess board address:
f5
true

C:\prakashclasses>java Test
Enter chess board address:
h8
false

C:\prakashclasses>java Test
Enter chess board address:
18
true

22. Impl prg to convert lower case chars to upper case and vice versa (swapcase).
---------------------------------------------------------------------------------
import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		String ss = "";
		for(int i=0;i<s.length();i++){
			if(s.charAt(i)>='a' && s.charAt(i)<='z')
				ss=ss+(char)(s.charAt(i)-32);
			if(s.charAt(i)>='A' && s.charAt(i)<='Z')
				ss=ss+(char)(s.charAt(i)+32);
		}
		System.out.println(ss);
	}
}

output:
-------
WeLcOmE
wElCoMe

23. Impl prg to remove special characters present in the given str.
-------------------------------------------------------------------
a-z, A-Z and 0-9 ----> add into ss else ignore

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any string:");
		String s = obj.nextLine();

		String ss = "";
		for(int i=0;i<s.length();i++){
			char ch = s.charAt(i);
			if((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||(ch>='0'&&ch<='9'))
				ss=ss+ch;
		}
		System.out.println(ss);
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter any string:
ca$h
cah

C:\prakashclasses>java Test
Enter any string:
prakash @ gmail . com # 123 % 789
prakashgmailcom123789

24. Impl prg to convert the given integer value into english word.
------------------------------------------------------------------
Ex:
---
	123 ----> one two three
	4510 ---> four five one zero

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter any num:");//123
		String s = obj.nextLine();
		for(int i=0;i<s.length();i++){
			char ch = s.charAt(i);
			switch(ch){
			case '0': System.out.print("zero ");break;
			case '1': System.out.print("one ");break;
			case '2': System.out.print("two ");break;
			case '3': System.out.print("three ");break;
			case '4': System.out.print("four ");break;
			case '5': System.out.print("five ");break;
			case '6': System.out.print("six ");break;
			case '7': System.out.print("seven ");break;
			case '8': System.out.print("eight ");break;
			case '9': System.out.print("nine ");break;		
			}
		}
	}
}

output:
-------
C:\prakashclasses>java Test
Enter any num:
123
one two three
C:\prakashclasses>java Test
Enter any num:
89107
eight nine one zero seven

25. Impl prg to validate ATM pin number.
----------------------------------------
[0-9]{4}

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter atm pin num:");
		String s = obj.nextLine();
		System.out.println(s.matches("[0-9]{4}"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter atm pin num:
1234
true

C:\prakashclasses>java Test
Enter atm pin num:
1209
true

C:\prakashclasses>java Test
Enter atm pin num:
12345
false

C:\prakashclasses>java Test
Enter atm pin num:
a123
false

26. Impl prg to validate mobile number
--------------------------------------
10 digits and first digit ---> 5 or 6 or 7 or 8 or 9

[5-9][0-9]{9}

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter mobile num:");
		String s = obj.nextLine();
		System.out.println(s.matches("[5-9][0-9]{9}"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter mobile num:
7386237319
true

C:\prakashclasses>java Test
Enter mobile num:
1786237319
false

C:\prakashclasses>java Test
Enter mobile num:
73862373198
false

27. Impl prg to validate gmail id
---------------------------------
abc@gmail.com 

[a-z][a-zA-Z0-9][a-zA-Z0-9]+@gamil[.]com

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter gmail id:");
		String s = obj.nextLine();
		System.out.println(s.matches("[a-z][a-zA-Z0-9][a-zA-Z0-9]+@gmail[.]com"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter gmail id:
abc@gmail.com
true

C:\prakashclasses>java Test
Enter gmail id:
1abc@gmail.com
false

C:\prakashclasses>java Test
Enter gmail id:
abc$def@gmail.com
false

C:\prakashclasses>java Test
Enter gmail id:
prakash@facebook.com
false

28. Impl prg to validate student university hall ticket number
--------------------------------------------------------------
DS00001
DS[0-9]{5}

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter student id:");
		String s = obj.nextLine();
		System.out.println(s.matches("DS[0-9]{5}"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter student id:
DS00001
true

C:\prakashclasses>java Test
Enter student id:
DS00045
true

C:\prakashclasses>java Test
Enter student id:
TS00045
false

29. Impl prg to validate bike registration number
-------------------------------------------------
TS 21 CA 1234

TS[0-9]{2}[A-Z]{2}[0-9]{4}

import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter bike number:");
		String s = obj.nextLine();
		System.out.println(s.matches("TS[0-9]{2}[A-Z]{2}[0-9]{4}"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter bike number:
TS03AP1234
true

C:\prakashclasses>java Test
Enter bike number:
TS123A1234
false

30. Impl prg to validate given date.
------------------------------------
03-01-2023

[0-3][0-9]-[0-1][0-2]-202[3-9]


import java.util.*;

class Test 
{
	public static void main(String[] args) throws Exception
	{
		Scanner obj = new Scanner(System.in);

		System.out.println("Enter date value:");
		String s = obj.nextLine();
		System.out.println(s.matches("[0-3][0-9]-[0-1][0-2]-202[3-9]"));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter date value:
03-01-2023
true

C:\prakashclasses>java Test
Enter date value:
03-01-2029
true



Arrays Rotations:
~~~~~~~~~~~~~~~~~
we have to move elements from left to right or right to left w.r.t number of elements. we have two types of rotations are existed left rotation and right rotation.

Ex:
---
	[1, 2, 3, 4, 5] -------> Left Rotation


	1 rotation ------------> [2, 3, 4, 5, 1]
	2 rotations -----------> [3, 4, 5, 1, 2]
	3 rotations -----------> [4, 5, 1, 2, 3]
	4 rotations -----------> [5, 1, 2, 3, 4]
	5 rotations -----------> [1, 2, 3, 4, 5]
	6 rotations = 1 ro ----> [2, 3, 4, 5, 1] ----> 1st rotation

Ex:
---
	[1, 2, 3, 4, 5] -------> Right Rotation

	1 rotation ------------> [5, 1, 2, 3, 4]
	2 rotations -----------> [4, 5, 1, 2, 3]
	3 rotations -----------> [3, 4, 5, 1, 2]
	4 rotations -----------> [2, 3, 4, 5, 1]
	5 rotations -----------> [1, 2, 3, 4, 5]
	6 rotations -----------> [5, 1, 2, 3, 4] ----> 1st rotation

The following are the different methods to perform array rotations...

1) Brute Force Algorithm
2) Temp variable concept
3) Temp array method-1
4) Temp array method-2
5) Reversal Algorithm

1) Brute Force Algorithm
------------------------
Ex:Left Rotation
----------------
import java.util.*;
class Demo{
	static void leftRotation1(int a[],int r){
		int i,j,prev,temp;
		r=r%a.length;
		for(i=0;i<r;i++)
		{
			prev = a[0];
			for(j=a.length-1;j>=0;j--){
				temp = a[j];
				a[j] = prev;
				prev = temp;
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Rotations ===> "+Arrays.toString(a));
		Demo.leftRotation1(a,r);
		System.out.println("After Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
Enter number of rotations:
1
Before Rotations ===> [1, 2, 3, 4, 5]
After Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Rotations ===> [1, 2, 3, 4, 5]
After Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Rotations ===> [1, 2, 3, 4, 5]
After Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Rotations ===> [1, 2, 3, 4, 5]
After Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Rotations ===> [1, 2, 3, 4, 5]
After Rotations ===> [1, 2, 3, 4, 5]

Ex:Right Rotation
-----------------
import java.util.*;
class Demo{
	static void rightRotation1(int a[],int r){
		int i,j,prev,temp;
		r=r%a.length;
		for(i=0;i<r;i++)
		{
			prev = a[a.length-1];
			for(j=0;j<a.length;j++){
				temp = a[j];
				a[j] = prev;
				prev = temp;
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Right Rotation ===> "+Arrays.toString(a));
		Demo.rightRotation1(a,r);
		System.out.println("After Right Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
Enter number of rotations:
1
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [1, 2, 3, 4, 5]

2) Temp variable concept
------------------------
Ex: Left Rotation
-----------------
import java.util.*;
class Demo{
	static void leftRotation2(int a[],int r){
		int i,j,temp;
		r=r%a.length;
		for(i=0;i<r;i++)
		{
			temp = a[0];
			for(j=0;j<a.length-1;j++)
				a[j] = a[j+1];
			a[a.length-1] = temp;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Left Rotation ===> "+Arrays.toString(a));
		Demo.leftRotation2(a,r);
		System.out.println("After Left Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter number of rotations:
1
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [1, 2, 3, 4, 5]

C:\prakashclasses>java Test
Enter number of rotations:
6
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [2, 3, 4, 5, 1]


Ex: Right Rotation
------------------
import java.util.*;
class Demo{
	static void rightRotation2(int a[],int r){
		int i,j,temp;
		r=r%a.length;
		for(i=0;i<r;i++)
		{
			temp = a[a.length-1];
			for(j=a.length-1;j>0;j--)
				a[j] = a[j-1];
			a[0] = temp;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Right Rotation ===> "+Arrays.toString(a));
		Demo.rightRotation2(a,r);
		System.out.println("After Right Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter number of rotations:
1
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [1, 2, 3, 4, 5]

3) Temp array method-1
----------------------
Ex: Left Rotation
-----------------
import java.util.*;
class Demo{
	static void leftRotation3(int a[],int r){
		int i,j,n=a.length;
		r=r%a.length;
		int temp[] = new int[r];

		for(i=0;i<r;i++)
			temp[i] = a[i];

		for(i=r;i<n;i++)
			a[i-r] = a[i];

		for(i=0;i<r;i++)
			a[i+n-r] = temp[i];		
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Left Rotation ===> "+Arrays.toString(a));
		Demo.leftRotation3(a,r);
		System.out.println("After left Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter number of rotations:
1
Before Left Rotation ===> [1, 2, 3, 4, 5]
After left Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Left Rotation ===> [1, 2, 3, 4, 5]
After left Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Left Rotation ===> [1, 2, 3, 4, 5]
After left Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Left Rotation ===> [1, 2, 3, 4, 5]
After left Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Left Rotation ===> [1, 2, 3, 4, 5]
After left Rotations ===> [1, 2, 3, 4, 5]

Ex: Right Rotation
------------------
import java.util.*;
class Demo{
	static void rightRotation3(int a[],int r){
		int i,j,n=a.length;
		r=r%a.length;
		int temp[] = new int[r];

		for(i=0;i<r;i++)
			temp[i] = a[n-r+i];

		for(i=n-r-1;i>=0;i--)
			a[i+r] = a[i];

		for(i=0;i<r;i++)
			a[i] = temp[i];		
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Right Rotation ===> "+Arrays.toString(a));
		Demo.rightRotation3(a,r);
		System.out.println("After Right Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>java Test
Enter number of rotations:
1
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [1, 2, 3, 4, 5]

4) Temp array method-2
----------------------
Ex: Left Rotation
-----------------
import java.util.*;
class Demo{
	static void leftRotation4(int a[],int r){
		int i,n=a.length;
		r=r%a.length;
		int temp[] = new int[n];
		for(i=0;i<n;i++)
			temp[i] = a[(i+r)%n];

		for(i=0;i<n;i++)
			a[i] = temp[i];
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Left Rotation ===> "+Arrays.toString(a));
		Demo.leftRotation4(a,r);
		System.out.println("After Left Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter number of rotations:
1
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [1, 2, 3, 4, 5]

Ex: Right Rotation
------------------
import java.util.*;
class Demo{
	static void rightRotation4(int a[],int r){
		int i,n=a.length;
		r=r%a.length;
		int temp[] = new int[n];
		for(i=0;i<n;i++)
			temp[(i+r)%n] = a[i];

		for(i=0;i<n;i++)
			a[i] = temp[i];
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Right Rotation ===> "+Arrays.toString(a));
		Demo.rightRotation4(a,r);
		System.out.println("After Right Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter number of rotations:
1
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [1, 2, 3, 4, 5]

5) Reversal Algorithm
~~~~~~~~~~~~~~~~~~~~~
Ex: Left Rotation:
------------------
import java.util.*;
class Demo{
	static void reverse(int a[],int b,int e){
		int temp;
		while(b<e){
			temp = a[b];
			a[b] = a[e];
			a[e] = temp;
			b++;
			e--;
		}
	}
	static void leftRotation5(int a[],int r){
		int i,n=a.length;
		r=r%a.length;
		reverse(a,0,r-1);
		reverse(a,r,n-1);
		reverse(a,0,n-1);
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Left Rotation ===> "+Arrays.toString(a));
		Demo.leftRotation5(a,r);
		System.out.println("After Left Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter number of rotations:
1
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Left Rotation ===> [1, 2, 3, 4, 5]
After Left Rotations ===> [1, 2, 3, 4, 5]

Ex: Right Rotation
------------------
import java.util.*;
class Demo{
	static void reverse(int a[],int b,int e){
		int temp;
		while(b<e){
			temp = a[b];
			a[b] = a[e];
			a[e] = temp;
			b++;
			e--;
		}
	}
	static void rightRotation5(int a[],int r){
		int i,n=a.length;
		r=r%a.length;
		reverse(a,0,n-1);
		reverse(a,0,r-1);
		reverse(a,r,n-1);		
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int a[] = {1, 2, 3, 4, 5};

		System.out.println("Enter number of rotations:");
		int r = obj.nextInt();

		System.out.println("Before Right Rotation ===> "+Arrays.toString(a));
		Demo.rightRotation5(a,r);
		System.out.println("After Right Rotations ===> "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Enter number of rotations:
1
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [5, 1, 2, 3, 4]

C:\prakashclasses>java Test
Enter number of rotations:
2
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [4, 5, 1, 2, 3]

C:\prakashclasses>java Test
Enter number of rotations:
3
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [3, 4, 5, 1, 2]

C:\prakashclasses>java Test
Enter number of rotations:
4
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [2, 3, 4, 5, 1]

C:\prakashclasses>java Test
Enter number of rotations:
5
Before Right Rotation ===> [1, 2, 3, 4, 5]
After Right Rotations ===> [1, 2, 3, 4, 5]


programs on matrix
------------------
1) Impl a program to read and write matrix elements.
----------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9

2) Impl program to find transpose of the given matrix
-----------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		System.out.println("Transpose Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[j][i]+" ");
			}
			System.out.println();
		}
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
Transpose Matrix Elements Are:
1 4 7
2 5 8
3 6 9

3) Impl program to find sum of all elements in the matrix.
----------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sum = 0;
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				sum=sum+a[i][j];
			}
		}
		System.out.println(sum);
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
45

4) Impl program to find sum of all even and odd elements in the matrix.
-----------------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sume = 0, sumo = 0;
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				if(a[i][j]%2==0)
					sume=sume+a[i][j];
				else
					sumo=sumo+a[i][j];
			}
		}
		System.out.println("sum of even= "+sume);
		System.out.println("sum of odd= "+sumo);
		System.out.println("sum= "+(sume+sumo));
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
sum of even= 20
sum of odd= 25
sum= 45

5) Impl program to find row wise sum of elements in the matrix.
---------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sum;
		for(i=0;i<3;i++){
			sum=0;
			for(j=0;j<3;j++){
				sum=sum+a[i][j];
			}
			System.out.println(i+" row sum= "+sum);
		}
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
0 row sum= 6
1 row sum= 15
2 row sum= 24

6) Impl program to find col wise sum of elements in the matrix.
---------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sum;
		for(i=0;i<3;i++){
			sum=0;
			for(j=0;j<3;j++){
				sum=sum+a[j][i];
			}
			System.out.println(i+" col sum= "+sum);
		}
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
0 col sum= 12
1 col sum= 15
2 col sum= 18

7) Impl program to find sum of digonal elements in the matrix.
--------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sum=0;
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				if(i==j)
					sum=sum+a[i][j];
			}
		}
		System.out.println("sum of diagonal elements= "+sum);
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
sum of diagonal elements= 15

8) Impl program to find sum of opp digonal elements in the matrix.
------------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		int sum=0;
		for(i=0;i<3;i++){
			sum = sum + a[i][3-i-1];
		}
		System.out.println("sum of opp diagonal elements= "+sum);
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
sum of opp diagonal elements= 15

9) Impl program to find min/max element in the matrix.
------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		int max,min;
		max = a[0][0];
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				if(max<a[i][j])
					max = a[i][j];
			}
		}
		System.out.println("max element = "+max);
		min = a[0][0];
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				if(min>a[i][j])
					min = a[i][j];
			}
		}
		System.out.println("min element = "+min);		
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 -9
Matrix Elements Are:
1 2 3
4 5 6
7 8 -9
max element = 8
min element = -9

10) Impl program to find row wise min/max element in the matrix.
----------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		int max,min;
		for(i=0;i<3;i++){
			min = a[i][0];
			for(j=0;j<3;j++){
				if(min>a[i][j])
					min = a[i][j];
			}
			System.out.println(i+" row min element = "+min);	
		}

		for(i=0;i<3;i++){
			max = a[i][0];
			for(j=0;j<3;j++){
				if(max<a[i][j])
					max = a[i][j];
			}
			System.out.println(i+" row max element = "+max);
		}			
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 -6
-7 8 9
Matrix Elements Are:
1 2 3
4 5 -6
-7 8 9
0 row min element = 1
1 row min element = -6
2 row min element = -7
0 row max element = 3
1 row max element = 5
2 row max element = 9

11) Impl program to find col wise min/max element in the matrix.
----------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		int max,min;
		for(i=0;i<3;i++){
			min = a[0][i];
			for(j=0;j<3;j++){
				if(min>a[j][i])
					min = a[j][i];
			}
			System.out.println(i+" col min element = "+min);	
		}

		for(i=0;i<3;i++){
			max = a[0][i];
			for(j=0;j<3;j++){
				if(max<a[j][i])
					max = a[j][i];
			}
			System.out.println(i+" col max element = "+max);
		}			
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
0 col min element = 1
1 col min element = 2
2 col min element = 3
0 col max element = 7
1 col max element = 8
2 col max element = 9

12) Impl program to sort all elements in a row in asc/desc order?
-----------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		for(i=0;i<3;i++){
			Arrays.sort(a[i]);
		}

		System.out.println("Updated Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){//for(j=3-1;j>=0;j--)
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}		
	}
}

output:
-------
Enter matrix elements:
1 3 2
7 0 9
5 8 4
Matrix Elements Are:
1 3 2
7 0 9
5 8 4
Updated Matrix Elements Are:
1 2 3
0 7 9
4 5 8

13) Impl program to sort all elements in a col in asc/desc order?
-----------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		int[][] b = new int[3][3];
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++){
				b[i][j] = a[j][i];
			}
		}

		for(i=0;i<3;i++){
			Arrays.sort(b[i]);
		}

		System.out.println("Updated Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=3-1;j>=0;j--){
				System.out.print(b[j][i]+" ");
			}
			System.out.println();
		}		
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 6
2 4 5
Matrix Elements Are:
1 2 3
4 5 6
2 4 5
Updated Matrix Elements Are:
3 2 1
5 4 2
6 5 4

14) Impl program to swap two given rows
---------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,t;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		System.out.println("Enter rows to swap..");
		int r1 = obj.nextInt();
		int r2 = obj.nextInt();
		for(i=0;i<3;i++)
		{
			t = a[r1-1][i];
			a[r1-1][i] = a[r2-1][i];
			a[r2-1][i] = t;
		}

		System.out.println("Updated Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}		
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
Enter rows to swap..
1
3
Updated Matrix Elements Are:
7 8 9
4 5 6
1 2 3

15) Impl program to swap two given cols
---------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,t;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		System.out.println("Enter cols to swap..");
		int r1 = obj.nextInt();
		int r2 = obj.nextInt();
		for(i=0;i<3;i++)
		{
			t = a[i][r1-1];
			a[i][r1-1] = a[i][r2-1];
			a[i][r2-1] = t;
		}

		System.out.println("Updated Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}		
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
Enter cols to swap..
1
3
Updated Matrix Elements Are:
3 2 1
6 5 4
9 8 7

16) Impl program to swap main and opp diagonal elements
-------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,t;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		for(i=0;i<3;i++)
		{
			t = a[i][i];
			a[i][i] = a[i][3-i-1];
			a[i][3-i-1] = t;
		}

		System.out.println("Updated Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}		
	}
}

output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
Updated Matrix Elements Are:
3 2 1
4 5 6
9 8 7

17) Impl program to check whether the given matrix is identity matrix or not.
------------------------------------------------------------------------------
1 2 3 
4 5 6
7 8 9

false

1 0 0 
0 1 0 
0 0 1

true

all digonal elements must be ---> 1
all non-diagonal elements ------> 0

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,t;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}

		boolean flag = true;
		
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				if(i==j && a[i][j]!=1)
				{
					flag = false;
					break;
				}
				if(i!=j && a[i][j]!=0)
				{
					flag = false;
					break;
				}
			}
		}
		System.out.println(flag);
	}
}

output:
-------
C:\3pm>java Test
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
false

C:\3pm>java Test
Enter matrix elements:
1 0 0
0 1 0
0 0 1
Matrix Elements Are:
1 0 0
0 1 0
0 0 1
true

18) Impl program to perform scalar matrix multiplication.
---------------------------------------------------------
1 2 3
4 5 6
7 8 9
n=2

2 4 6
8 10 12
14 16 18

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,n;
		int a[][] = new int[3][3];
		System.out.println("Enter matrix elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
		System.out.println("Enter n value:");
		n=obj.nextInt();

		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				System.out.print((n*a[i][j])+" ");
			}
			System.out.println();
		}
	}
}


output:
-------
Enter matrix elements:
1 2 3
4 5 6
7 8 9
Matrix Elements Are:
1 2 3
4 5 6
7 8 9
Enter n value:
2
2 4 6
8 10 12
14 16 18

19) Impl program to perform addition/subtraction of two matrices
----------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j;
		int a[][] = new int[3][3];
		int b[][] = new int[3][3];
		int c[][] = new int[3][3];
		System.out.println("Enter matrix:A elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}
		System.out.println("Enter matrix:B elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				b[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix:A Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		System.out.println("Matrix:B Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(b[i][j]+" ");
			}
			System.out.println();
		}
		
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				//c[i][j] = a[i][j] + b[i][j];
				c[i][j] = a[i][j] - b[i][j];
			}
		}
		
		System.out.println("Matrix:C Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(c[i][j]+" ");
			}
			System.out.println();
		}
	}
}

output:
-------
Enter matrix:A elements:
1 2 3
4 5 6
7 8 9
Enter matrix:B elements:
1 0 0
0 1 0
1 1 0
Matrix:A Elements Are:
1 2 3
4 5 6
7 8 9
Matrix:B Elements Are:
1 0 0
0 1 0
1 1 0
Matrix:C Elements Are:
2 2 3
4 6 6
8 9 9

20) Impl program to perform multiplication of two matrices
----------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		int i,j,k;
		int a[][] = new int[3][3];
		int b[][] = new int[3][3];
		int c[][] = new int[3][3];
		System.out.println("Enter matrix:A elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				a[i][j] = obj.nextInt();
			}
		}
		System.out.println("Enter matrix:B elements:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				b[i][j] = obj.nextInt();
			}
		}

		System.out.println("Matrix:A Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		System.out.println("Matrix:B Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(b[i][j]+" ");
			}
			System.out.println();
		}
		
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				c[i][j] = 0;
				for(k=0;k<3;k++){
					c[i][j] = c[i][j] + (a[i][k]*b[k][j]);
				}
			}
		}
		
		System.out.println("Matrix:C Elements Are:");
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				System.out.print(c[i][j]+" ");
			}
			System.out.println();
		}
	}
}


output:
-------
Enter matrix:A elements:
1 2 3
4 5 6
7 8 9
Enter matrix:B elements:
1 0 0
0 1 0
0 0 1
Matrix:A Elements Are:
1 2 3
4 5 6
7 8 9
Matrix:B Elements Are:
1 0 0
0 1 0
0 0 1
Matrix:C Elements Are:
1 2 3
4 5 6
7 8 9

Sorting and Searching 
~~~~~~~~~~~~~~~~~~~~~
01. Introduction to sorting
02. Gnerating Random values for sorting array
03. Basics of sorting
04. Arrays.toString() method
05. Arrays.sort() method
06. Bubble sort
07. Selection sort
08. Insertion sort
09. Qucik sort
10. Merge sort
11. Shell sort
12. Counting sort
13. Comparison of sorting algorithms
14. Selection of best sorting algorithm
15. Introduction to searching
16. Linear search for first occurrence
17. Linear search for first and second occurrences
18. Linear search for all occurrences
19. Binary search using iteration/loops
20. Binary search using Recursion
21. Binary search for first half of array
22. Binary search for second half of array
23. Binary search with customized ranges
24. Arrays.binarySearch() method


Introduction to sorting
-----------------------
sorting means arranging the data in asc/desc order for making searching process very easy.

Before starting sorting we required two functions

boolean less(int value1,int value2){
	return value1<value2;
}

boolean more(int value1,int value2){
	return value1>value2;
}

23, 10  ---> 10, 23
23, 24 ----> 23, 24

Generating Random values for sorting array
-----------------------------------------
Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("Array Elements are:");
		for(int i=0;i<a.length;i++)
			System.out.println(a[i]);
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
Array Elements are:
2
25
41
13
20
17
7
19
44
46

C:\prakashclasses>java Test
Array Elements are:
0
27
1
7
45
29
5
45
6
40

Basics of sorting
-----------------
The following are the small code snippets are used to perform basic sorting techniques over the given data.

case1: sorting data in ascending order
case2: sorting data in descending order
case3: sorting data in ascending order with given range
case4: sorting data in descending order with given range

case1: sorting data in ascending order
-------------------------------------

import java.util.*;
class Test 
{
	static boolean more(int value1,int value2){
		return value1>value2;
	}
	static boolean less(int value1,int value2){
		return value1<value2;
	}
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("Array Elements before sorting in asc order are:");
		for(int item:a)
			System.out.println(item);
		//logic

		int i,j,t,n=a.length;
		for(i=0;i<n;i++)
		{
			for(j=i+1;j<n;j++){
				if(more(a[i],a[j])){
					t=a[i];
					a[i]=a[j];
					a[j]=t;
				}
			}
		}

		System.out.println("Array Elements after sorting in asc order are:");
		for(int item:a)
			System.out.println(item);
	}
}

output:
-------
Array Elements before sorting in asc oder are:
32
11
33
49
30
31
26
21
49
31
Array Elements after sorting in asc oder are:
11
21
26
30
31
31
32
33
49
49

case2: sorting data in descending order
--------------------------------------
import java.util.*;
class Test 
{
	static boolean more(int value1,int value2){
		return value1>value2;
	}
	static boolean less(int value1,int value2){
		return value1<value2;
	}
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("Array Elements before sorting in desc order are:");
		for(int item:a)
			System.out.println(item);
		//logic

		int i,j,t,n=a.length;
		for(i=0;i<n;i++)
		{
			for(j=i+1;j<n;j++){
				if(less(a[i],a[j])){
					t=a[i];
					a[i]=a[j];
					a[j]=t;
				}
			}
		}

		System.out.println("Array Elements after sorting in desc order are:");
		for(int item:a)
			System.out.println(item);
	}
}

output:
-------
C:\prakashclasses>java Test
Array Elements before sorting in desc oder are:
15
28
46
47
45
13
30
17
33
29
Array Elements after sorting in desc oder are:
47
46
45
33
30
29
28
17
15
13

case3: sorting data in ascending order with given range
-------------------------------------------------------
import java.util.*;
class Test 
{
	static boolean more(int value1,int value2){
		return value1>value2;
	}
	static boolean less(int value1,int value2){
		return value1<value2;
	}
	public static void main(String[] args) 
	{
		Random r = new Random();
		Scanner obj = new Scanner(System.in);
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("Array Elements before sorting in asc oder are:");
		for(int item:a)
			System.out.print(item+" ");
		System.out.println();
		//logic

		System.out.println("Enter source index:");
		int si = obj.nextInt();
		System.out.println("Enter end index:");
		int ei = obj.nextInt();

		int i,j,t,n=a.length;
		for(i=si;i<ei;i++)
		{
			for(j=i+1;j<ei;j++){
				if(more(a[i],a[j])){
					t=a[i];
					a[i]=a[j];
					a[j]=t;
				}
			}
		}

		System.out.println("Array Elements after sorting in asc oder are:");
		for(int item:a)
			System.out.print(item+" ");
		System.out.println();
	}
}

output:
-------
Array Elements before sorting in asc oder are:
31 26 32 36 39 36 20 21 2 24
Enter source index:
2
Enter end index:
7
Array Elements after sorting in asc oder are:
31 26 20 32 36 36 39 21 2 24

case4: sorting data in descending oder with given range
-------------------------------------------------------
import java.util.*;
class Test 
{
	static boolean more(int value1,int value2){
		return value1>value2;
	}
	static boolean less(int value1,int value2){
		return value1<value2;
	}
	public static void main(String[] args) 
	{
		Random r = new Random();
		Scanner obj = new Scanner(System.in);
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("Array Elements before sorting in desc oder are:");
		for(int item:a)
			System.out.print(item+" ");
		System.out.println();
		//logic

		System.out.println("Enter source index:");
		int si = obj.nextInt();
		System.out.println("Enter end index:");
		int ei = obj.nextInt();

		int i,j,t,n=a.length;
		for(i=si;i<ei;i++)
		{
			for(j=i+1;j<ei;j++){
				if(less(a[i],a[j])){
					t=a[i];
					a[i]=a[j];
					a[j]=t;
				}
			}
		}

		System.out.println("Array Elements after sorting in desc oder are:");
		for(int item:a)
			System.out.print(item+" ");
		System.out.println();
	}
}


output:
-------
Array Elements before sorting in desc oder are:
39 16 28 21 13 33 43 18 5 8
Enter source index:
2
Enter end index:
7
Array Elements after sorting in desc oder are:
39 16 43 33 28 21 13 18 5 8

04. Arrays.toString() method
----------------------------
This method returns a string representation of the content of the specified array.

Ex:
---
import java.util.*;
class Test 
{
	static boolean more(int value1,int value2){
		return value1>value2;
	}
	static boolean less(int value1,int value2){
		return value1<value2;
	}
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("before sorting in asc order are:"+Arrays.toString(a));
		//logic

		int i,j,t,n=a.length;
		for(i=0;i<n;i++)
		{
			for(j=i+1;j<n;j++){
				if(more(a[i],a[j])){
					t=a[i];
					a[i]=a[j];
					a[j]=t;
				}
			}
		}

		System.out.println("after sorting in asc order are:"+Arrays.toString(a));
	}
}


output:
-------
before sorting in asc order are:[1, 21, 22, 27, 15, 5, 24, 40, 37, 42]
after sorting in asc order are:[1, 5, 15, 21, 22, 24, 27, 37, 40, 42]

05. Arrays.sort() method
------------------------
Arrays class contains a static method sort(), it is used to sort the array elements in an order. the following are the different cases of sorting array.

case1: Sorting primitive values in ascending order
case2: Sorting primitive values in ascending order with given range
case3: Sorting Integer objects in ascending order
case4: Sorting Integer objects in descending order
case5: Sorting String objects in ascending order
case6: Sorting String objects in descending order
case7: Sorting Student objects in ascending order
case8: Sorting Student objects in descending order

case1: Sorting primitive values in ascending order
---------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("before sorting  "+Arrays.toString(a));
		Arrays.sort(a);
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [41, 26, 33, 25, 31, 1, 47, 17, 3, 36]
after sorting  [1, 3, 17, 25, 26, 31, 33, 36, 41, 47]

case2: Sorting primitive values in ascending order with given range
-------------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int[] a = new int[10];
		
		for(int i=0;i<a.length;i++)
			a[i] = r.nextInt(50);

		System.out.println("before sorting  "+Arrays.toString(a));
		int beginIndex = 3;
		int endIndex = 8;
		Arrays.sort(a,beginIndex,endIndex);//sort the values with range of 3 to 7
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [18, 17, 24, 47, 19, 45, 17, 43, 40, 19]
after sorting  [18, 17, 24, 17, 19, 43, 45, 47, 40, 19]

case3: Sorting Integer objects in ascending order
-------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Integer[] a = {10, 19, 34, 11, 45, 23, 15, 12, 30, 33};
		
		System.out.println("before sorting  "+Arrays.toString(a));
		Arrays.sort(a);
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [10, 19, 34, 11, 45, 23, 15, 12, 30, 33]
after sorting  [10, 11, 12, 15, 19, 23, 30, 33, 34, 45]

case4: Sorting Integer objects in descending order
--------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Integer[] a = {10, 19, 34, 11, 45, 23, 15, 12, 30, 33};
		
		System.out.println("before sorting  "+Arrays.toString(a));
		Arrays.sort(a,Collections.reverseOrder());
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [10, 19, 34, 11, 45, 23, 15, 12, 30, 33]
after sorting  [45, 34, 33, 30, 23, 19, 15, 12, 11, 10]

case5: Sorting String objects in ascending order
------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		String[] a = {"CCC","AAA","WWW","ZZZ","BBB","YYY","XXX"};
		
		System.out.println("before sorting  "+Arrays.toString(a));
		Arrays.sort(a);
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [CCC, AAA, WWW, ZZZ, BBB, YYY, XXX]
after sorting  [AAA, BBB, CCC, WWW, XXX, YYY, ZZZ]

case6: Sorting String objects in descending order
-------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		String[] a = {"CCC","AAA","WWW","ZZZ","BBB","YYY","XXX"};
		
		System.out.println("before sorting  "+Arrays.toString(a));
		Arrays.sort(a,Collections.reverseOrder());
		System.out.println("after sorting  "+Arrays.toString(a));
	}
}

output:
-------
before sorting  [CCC, AAA, WWW, ZZZ, BBB, YYY, XXX]
after sorting  [ZZZ, YYY, XXX, WWW, CCC, BBB, AAA]

case7: Sorting Student objects in ascending order based on student id
---------------------------------------------------------------------
import java.util.*;
class Student{
	int sid;
	String name;
	Student(int sid,String name){
		this.sid = sid;
		this.name = name;
	}
	public String toString(){
		return "Id="+sid+" and Name="+name;
	}
}

class SortById implements Comparator<Student>
{
	public int compare(Student s1, Student s2){
		return s1.sid-s2.sid;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(444,"AAA");
		Student s2 = new Student(111,"BBB");
		Student s3 = new Student(555,"CCC");
		Student s4 = new Student(333,"DDD");
		Student s5 = new Student(222,"EEE");

		Student[] a = {s1,s2,s3,s4,s5};
		
		for(Student s:a)
			System.out.println(s);
		Arrays.sort(a,new SortById());
		System.out.println("after sorting");
		for(Student s:a)
			System.out.println(s);
	}
}

output:
-------
Id=444 and Name=AAA
Id=111 and Name=BBB
Id=555 and Name=CCC
Id=333 and Name=DDD
Id=222 and Name=EEE
after sorting
Id=111 and Name=BBB
Id=222 and Name=EEE
Id=333 and Name=DDD
Id=444 and Name=AAA
Id=555 and Name=CCC

case8: Sorting Student objects in descending order based on student id
---------------------------------------------------------------------
import java.util.*;
class Student{
	int sid;
	String name;
	Student(int sid,String name){
		this.sid = sid;
		this.name = name;
	}
	public String toString(){
		return "Id="+sid+" and Name="+name;
	}
}

class SortById implements Comparator<Student>
{
	public int compare(Student s1, Student s2){
		return s2.sid-s1.sid;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(444,"AAA");
		Student s2 = new Student(111,"BBB");
		Student s3 = new Student(555,"CCC");
		Student s4 = new Student(333,"DDD");
		Student s5 = new Student(222,"EEE");

		Student[] a = {s1,s2,s3,s4,s5};
		
		for(Student s:a)
			System.out.println(s);
		Arrays.sort(a,new SortById());
		System.out.println("after sorting");
		for(Student s:a)
			System.out.println(s);
	}
}

output:
-------
Id=444 and Name=AAA
Id=111 and Name=BBB
Id=555 and Name=CCC
Id=333 and Name=DDD
Id=222 and Name=EEE
after sorting
Id=555 and Name=CCC
Id=444 and Name=AAA
Id=333 and Name=DDD
Id=222 and Name=EEE
Id=111 and Name=BBB

case9: Sorting Student objects in ascending order based on student name
-----------------------------------------------------------------------
import java.util.*;
class Student{
	int sid;
	String name;
	Student(int sid,String name){
		this.sid = sid;
		this.name = name;
	}
	public String toString(){
		return "Id="+sid+" and Name="+name;
	}
}

class SortById implements Comparator<Student>
{
	public int compare(Student s1, Student s2){
		return (s1.name).compareTo(s2.name);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(444,"BBB");
		Student s2 = new Student(111,"AAA");
		Student s3 = new Student(555,"EEE");
		Student s4 = new Student(333,"DDD");
		Student s5 = new Student(222,"XXX");

		Student[] a = {s1,s2,s3,s4,s5};
		
		for(Student s:a)
			System.out.println(s);
		Arrays.sort(a,new SortById());
		System.out.println("after sorting");
		for(Student s:a)
			System.out.println(s);
	}
}

output:
-------
Id=444 and Name=BBB
Id=111 and Name=AAA
Id=555 and Name=EEE
Id=333 and Name=DDD
Id=222 and Name=XXX
after sorting
Id=111 and Name=AAA
Id=444 and Name=BBB
Id=333 and Name=DDD
Id=555 and Name=EEE
Id=222 and Name=XXX

case10: Sorting Student objects in descending order based on student name
-------------------------------------------------------------------------
import java.util.*;
class Student{
	int sid;
	String name;
	Student(int sid,String name){
		this.sid = sid;
		this.name = name;
	}
	public String toString(){
		return "Id="+sid+" and Name="+name;
	}
}

class SortById implements Comparator<Student>
{
	public int compare(Student s1, Student s2){
		return -(s1.name).compareTo(s2.name);
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(444,"BBB");
		Student s2 = new Student(111,"AAA");
		Student s3 = new Student(555,"EEE");
		Student s4 = new Student(333,"DDD");
		Student s5 = new Student(222,"XXX");

		Student[] a = {s1,s2,s3,s4,s5};
		
		for(Student s:a)
			System.out.println(s);
		Arrays.sort(a,new SortById());
		System.out.println("after sorting");
		for(Student s:a)
			System.out.println(s);
	}
}

output:
-------
Id=444 and Name=BBB
Id=111 and Name=AAA
Id=555 and Name=EEE
Id=333 and Name=DDD
Id=222 and Name=XXX
after sorting
Id=222 and Name=XXX
Id=555 and Name=EEE
Id=333 and Name=DDD
Id=444 and Name=BBB
Id=111 and Name=AAA

06. Bubble sort
---------------

for(i=0;i<n-1;i++)
{
	for(j=0;j<n-1-i;j++)
	{
		if(a[j]>a[j+1]){ 
			swap a[j] and a[j+1]
		}
	}
}

asc ---> a[j]>a[j+1]
desc --> a[j]<a[j+1]


Ex:
---
import java.util.*;
class Demo{
	static void bubbleSortAsc(int[] a){
		int i,j,t,n=a.length;
		for(i=0;i<n-1;i++)
		{
			for(j=0;j<n-1-i;j++)
			{
				if(a[j]>a[j+1]){
					t=a[j];
					a[j]=a[j+1];
					a[j+1]=t;
				}
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.bubbleSortAsc(a);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

output:
-------
before asc order: [58, 42, 6, 82, 40, 87, 79, 45, 74, 38]
after asc order: [6, 38, 40, 42, 45, 58, 74, 79, 82, 87]

Ex:
---
import java.util.*;
class Demo{
	static void bubbleSortDesc(int[] a){
		int i,j,t,n=a.length;
		for(i=0;i<n-1;i++)
		{
			for(j=0;j<n-1-i;j++)
			{
				if(a[j]<a[j+1]){
					t=a[j];
					a[j]=a[j+1];
					a[j+1]=t;
				}
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.bubbleSortDesc(a);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [46, 64, 43, 71, 37, 91, 95, 62, 49, 35]
after desc order: [95, 91, 71, 64, 62, 49, 46, 43, 37, 35]

Insertion sort
--------------
Ex:
---
import java.util.*;
class Demo{
	static void insertionSortAsc(int[] a){
		int i,j,temp,n=a.length;
		for(i=1;i<n;i++)
		{
			temp=a[i];
			j=i-1;
			while(j>=0 && a[j]>temp){
				a[j+1]=a[j];
				j--;
			}
			a[j+1] = temp;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.insertionSortAsc(a);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

output:
-------
before asc order: [70, 39, 88, 28, 87, 75, 64, 10, 10, 65]
after asc order: [10, 10, 28, 39, 64, 65, 70, 75, 87, 88]


Ex:
---
import java.util.*;
class Demo{
	static void insertionSortDesc(int[] a){
		int i,j,temp,n=a.length;
		for(i=1;i<n;i++)
		{
			temp=a[i];
			j=i-1;
			while(j>=0 && a[j]<temp){
				a[j+1]=a[j];
				j--;
			}
			a[j+1] = temp;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.insertionSortDesc(a);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [33, 26, 65, 62, 67, 78, 88, 81, 88, 71]
after desc order: [88, 88, 81, 78, 71, 67, 65, 62, 33, 26]

selection sort:
---------------
Ex:
---
import java.util.*;
class Demo{
	static void selectionSortAsc(int[] a){
		int i,min,j,temp,n=a.length;
		for(i=0;i<n-1;i++)
		{
			min=i;
			for(j=i+1;j<n;j++)
			{
				if(a[j]<a[min])
					min=j;
			}
			if(min!=i)
			{
				temp=a[i];
				a[i] = a[min];
				a[min] = temp;
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.selectionSortAsc(a);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

output:
-------
before asc order: [89, 32, 22, 76, 34, 72, 65, 79, 68, 57]
after asc order: [22, 32, 34, 57, 65, 68, 72, 76, 79, 89]

Ex:
---
import java.util.*;
class Demo{
	static void selectionSortDesc(int[] a){
		int i,min,j,temp,n=a.length;
		for(i=0;i<n-1;i++)
		{
			min=i;
			for(j=i+1;j<n;j++)
			{
				if(a[j]>a[min])
					min=j;
			}
			if(min!=i)
			{
				temp=a[i];
				a[i] = a[min];
				a[min] = temp;
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.selectionSortDesc(a);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [66, 30, 57, 30, 34, 62, 93, 62, 56, 44]
after desc order: [93, 66, 62, 62, 57, 56, 44, 34, 30, 30]

merge sort
----------
Ex:
---
import java.util.*;
class Demo{
	static void mergeSortAsc(int[] a,int n){
		if(n<2)
			return;
		int mid=n/2;
		int l[] = new int[mid];
		int r[] = new int[n-mid];
		int i;
		for(i=0;i<mid;i++)
			l[i] = a[i];
		for(i=mid;i<n;i++)
			r[i-mid] = a[i];
		mergeSortAsc(l,mid);
		mergeSortAsc(r,n-mid);
		merge(a,l,r,mid,n-mid);
	}
	static void merge(int[] a,int[] l,int[] r,int left,int right){
		int i=0,j=0,k=0;
		while(i<left && j<right){
			if(l[i]<=r[j])
				a[k++]=l[i++];
			else
				a[k++]=r[j++];
		}
		while(i<left)
			a[k++]=l[i++];
		while(j<right)
			a[k++]=r[j++];
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.mergeSortAsc(a,a.length);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}


output:
-------
before asc order: [76, 29, 75, 51, 17, 16, 99, 57, 5, 99]
after asc order: [5, 16, 17, 29, 51, 57, 75, 76, 99, 99]


Ex:
---
import java.util.*;
class Demo{
	static void mergeSortDesc(int[] a,int n){
		if(n<2)
			return;
		int mid=n/2;
		int l[] = new int[mid];
		int r[] = new int[n-mid];
		int i;
		for(i=0;i<mid;i++)
			l[i] = a[i];
		for(i=mid;i<n;i++)
			r[i-mid] = a[i];
		mergeSortDesc(l,mid);
		mergeSortDesc(r,n-mid);
		merge(a,l,r,mid,n-mid);
	}
	static void merge(int[] a,int[] l,int[] r,int left,int right){
		int i=0,j=0,k=0;
		while(i<left && j<right){
			if(l[i]>=r[j])
				a[k++]=l[i++];
			else
				a[k++]=r[j++];
		}
		while(i<left)
			a[k++]=l[i++];
		while(j<right)
			a[k++]=r[j++];
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.mergeSortDesc(a,a.length);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [99, 8, 57, 96, 89, 98, 93, 31, 75, 65]
after desc order: [99, 98, 96, 93, 89, 75, 65, 57, 31, 8]


Quick Sort:
-----------
Ex:
---
import java.util.*;
class Demo{
	static void quickSortAsc(int[] a,int lIndex,int rIndex){
		if(lIndex>=rIndex)
			return;
		int pivot, lp,rp,temp;
		pivot = a[rIndex];
		lp = lIndex;
		rp = rIndex;
		while(lp<rp){
			while(a[lp]<=pivot && lp<rp)
				lp++;
			while(a[rp]>=pivot && lp<rp)
				rp--;
			temp = a[lp];
			a[lp] = a[rp];
			a[rp] = temp;
		}	
		temp = a[lp];
		a[lp] = a[rIndex];
		a[rIndex] = temp;

		quickSortAsc(a,lIndex,lp-1);
		quickSortAsc(a,lp+1,rIndex);
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.quickSortAsc(a,0,a.length-1);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [58, 23, 10, 25, 21, 38, 89, 95, 27, 45]
after desc order: [10, 21, 23, 25, 27, 38, 45, 58, 89, 95]


Ex:
----
import java.util.*;
class Demo{
	static void quickSortDesc(int[] a,int lIndex,int rIndex){
		if(lIndex>=rIndex)
			return;
		int pivot, lp,rp,temp;
		pivot = a[rIndex];
		lp = lIndex;
		rp = rIndex;
		while(lp<rp){
			while(a[lp]>=pivot && lp<rp)
				lp++;
			while(a[rp]<=pivot && lp<rp)
				rp--;
			temp = a[lp];
			a[lp] = a[rp];
			a[rp] = temp;
		}	
		temp = a[lp];
		a[lp] = a[rIndex];
		a[rIndex] = temp;

		quickSortDesc(a,lIndex,lp-1);
		quickSortDesc(a,lp+1,rIndex);
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.quickSortDesc(a,0,a.length-1);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [94, 32, 41, 90, 55, 1, 67, 62, 52, 4]
after desc order: [94, 90, 67, 62, 55, 52, 41, 32, 4, 1]


Shell sort
~~~~~~~~~~
Ex:
---
import java.util.*;
class Demo{
	static void shellSortAsc(int[] a,int n){
		int gap,i,j,temp;
		for(gap=n/2;gap>=1;gap=gap/2){
			for(j=gap;j<n;j++){
				for(i=j-gap;i>=0;i=i-gap){
					if(a[i+gap]>a[i]){
						break;
					}
					else{
						temp = a[i+gap];
						a[i+gap] = a[i];
						a[i] = temp;
					}
				}
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.shellSortAsc(a,a.length);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

before asc order: [51, 73, 94, 53, 35, 97, 79, 38, 73, 81]
after asc order: [35, 38, 51, 53, 73, 73, 79, 81, 94, 97]


Ex:
---
import java.util.*;
class Demo{
	static void shellSortDesc(int[] a,int n){
		int gap,i,j,temp;
		for(gap=n/2;gap>=1;gap=gap/2){
			for(j=gap;j<n;j++){
				for(i=j-gap;i>=0;i=i-gap){
					if(a[i+gap]<a[i]){
						break;
					}
					else{
						temp = a[i+gap];
						a[i+gap] = a[i];
						a[i] = temp;
					}
				}
			}
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(100);

		System.out.println("before desc order: "+Arrays.toString(a));
		Demo.shellSortDesc(a,a.length);
		System.out.println("after desc order: "+Arrays.toString(a));
	}
}

output:
-------
before desc order: [83, 86, 14, 36, 85, 84, 65, 82, 82, 98]
after desc order: [98, 86, 85, 84, 83, 82, 82, 65, 36, 14]

counting sort:
--------------
Ex:
---
import java.util.*;
class Demo{
	static void countSortAsc(int a[], int lowerrange,int upperrange){
		int size = a.length;
		int range = upperrange-lowerrange;
		int[] count = new int[range];
		int i,j=0;
		for(i=0;i<size;i++)
			count[a[i]-lowerrange]++;
		for(i=0;i<range;i++){
			for(;count[i]>0;(count[i])--)
				a[j++] = i+lowerrange;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {23,24,22,21,26,25,27,28,21,21};

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.countSortAsc(a,20,30);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
before asc order: [23, 24, 22, 21, 26, 25, 27, 28, 21, 21]
after asc order: [21, 21, 21, 22, 23, 24, 25, 26, 27, 28]

Ex:
---
import java.util.*;
class Demo{
	static void countSortDesc(int a[], int lowerrange,int upperrange){
		int size = a.length;
		int range = upperrange-lowerrange;
		int[] count = new int[range];
		int i,j=0;
		for(i=0;i<size;i++)
			count[upperrange-a[i]]++;
		for(i=0;i<range;i++){
			for(;count[i]>0;(count[i])--)
				a[j++] = upperrange-i;
		}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		int a[] = {23,24,22,21,26,25,27,28,21,21};

		System.out.println("before asc order: "+Arrays.toString(a));
		Demo.countSortDesc(a,20,30);
		System.out.println("after asc order: "+Arrays.toString(a));
	}
}

output:
-------
C:\prakashclasses>java Test
before asc order: [23, 24, 22, 21, 26, 25, 27, 28, 21, 21]
after asc order: [28, 27, 26, 25, 24, 23, 22, 21, 21, 21]

Introduction to searching
-------------------------
searching is the process of finding an item in a collection of items. the item may be a keyword in a file, a record in the db, a node in a tree, element in an array.

the following are the two types of searching methods existed in data structures.

1) linear search
2) binary search

linear search first occurrence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int linearSearch(int[] a,int key){
		int i;
		for(i=0;i<a.length;i++){
			if(a[i]==key)
				return i;
		}
		return -1;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.linearSearch(a,key));
	}
}

C:\prakashclasses>java Test
[8, 4, 4, 1, 0, 0, 1, 8, 3, 6]
Enter element to search:
1
3

C:\prakashclasses>java Test
[6, 2, 2, 7, 9, 5, 9, 2, 2, 1]
Enter element to search:
3
-1

linear search first and second occurrence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static ArrayList linearSearch(int[] a,int key){
		int i,c=0;
		ArrayList list = new ArrayList();
		for(i=0;i<a.length;i++){
			if(a[i]==key){
				c++;
				list.add(i);
				if(c==2)
					break;
			}
		}
		return list;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.linearSearch(a,key));
	}
}

C:\prakashclasses>java Test
[9, 6, 5, 1, 6, 4, 8, 7, 4, 6]
Enter element to search:
6
[1, 4]

C:\prakashclasses>java Test
[4, 9, 8, 0, 4, 9, 3, 5, 5, 1]
Enter element to search:
9
[1, 5]

C:\prakashclasses>java Test
[2, 8, 6, 0, 2, 9, 7, 8, 9, 6]
Enter element to search:
0
[3]

linear search with all occurrences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static ArrayList linearSearch(int[] a,int key){
		int i;
		ArrayList list = new ArrayList();
		for(i=0;i<a.length;i++){
			if(a[i]==key){
				list.add(i);
			}
		}
		return list;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.linearSearch(a,key));
	}
}

C:\prakashclasses>java Test
[7, 5, 6, 5, 9, 9, 5, 6, 1, 2]
Enter element to search:
9
[4, 5]

C:\prakashclasses>java Test
[1, 4, 4, 9, 7, 4, 9, 4, 3, 7]
Enter element to search:
4
[1, 2, 5, 7]

C:\prakashclasses>java Test
[1, 5, 6, 1, 1, 0, 5, 6, 6, 8]
Enter element to search:
2
[]

binary search using iteration/loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int binarySearchIteration(int[] a,int key){
			int low,high,mid;
			low = 0;
			high = a.length-1;
			while(low<=high){
				mid = (low+high)/2;
				if(key==a[mid])
					return mid;
				else if(key<a[mid])
					high = mid-1;
				else
					low = mid+1;
			}
			return -1;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.binarySearchIteration(a,key));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[4, 0, 5, 9, 3, 0, 4, 0, 6, 4]
[0, 0, 0, 3, 4, 4, 4, 5, 6, 9]
Enter element to search:
5
7

C:\prakashclasses>java Test
[7, 2, 4, 2, 8, 8, 1, 2, 5, 7]
[1, 2, 2, 2, 4, 5, 7, 7, 8, 8]
Enter element to search:
9
-1

binary search using recursion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int binarySearchRecursion(int[] a,int key,int low,int high){
			int mid=(low+high)/2;
			if(low>high)
				return -1;
			else
			{
				if(key==a[mid])
					return mid;
				else if(key<a[mid])
					return binarySearchRecursion(a,key,low,mid-1);
				else
					return binarySearchRecursion(a,key,mid+1,high);
			}
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.binarySearchRecursion(a,key,0,a.length-1));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[5, 3, 9, 0, 2, 1, 4, 8, 0, 8]
[0, 0, 1, 2, 3, 4, 5, 8, 8, 9]
Enter element to search:
4
5

C:\prakashclasses>java Test
[5, 7, 6, 0, 0, 4, 3, 1, 7, 5]
[0, 0, 1, 3, 4, 5, 5, 6, 7, 7]
Enter element to search:
9
-1

binary search within first half
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int binarySearchRecursion(int[] a,int key,int low,int high){
			if(low<=high){
				int mid = (low+high)/2;
				if(a[mid]==key)
					return mid;
				else if(a[mid]<key)
					return binarySearchRecursion(a,key,mid+1,high);
				else
					return binarySearchRecursion(a,key,low,mid-1);
			}
			return -1;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.binarySearchRecursion(a,key,0,(a.length-1)/2));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[6, 4, 0, 3, 7, 8, 4, 6, 6, 7]
[0, 3, 4, 4, 6, 6, 6, 7, 7, 8]
Enter element to search:
7
-1

C:\prakashclasses>java Test
[7, 6, 8, 9, 7, 9, 0, 4, 0, 5]
[0, 0, 4, 5, 6, 7, 7, 8, 9, 9]
Enter element to search:
4
2

C:\prakashclasses>java Test
[0, 2, 9, 4, 0, 2, 1, 9, 5, 8]
[0, 0, 1, 2, 2, 4, 5, 8, 9, 9]
Enter element to search:
2
3

C:\prakashclasses>java Test
[7, 3, 6, 5, 2, 1, 9, 5, 2, 1]
[1, 1, 2, 2, 3, 5, 5, 6, 7, 9]
Enter element to search:
5
-1

binary search within second half
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int binarySearchRecursion(int[] a,int key,int low,int high){
			if(low<=high){
				int mid = (low+high)/2;
				if(a[mid]==key)
					return mid;
				else if(a[mid]<key)
					return binarySearchRecursion(a,key,mid+1,high);
				else
					return binarySearchRecursion(a,key,low,mid-1);
			}
			return -1;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Demo.binarySearchRecursion(a,key,(a.length-1)/2,a.length-1));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[8, 7, 5, 6, 9, 5, 0, 5, 2, 9]
[0, 2, 5, 5, 5, 6, 7, 8, 9, 9]
Enter element to search:
2
-1

C:\prakashclasses>java Test
[5, 7, 8, 6, 5, 2, 3, 7, 5, 2]
[2, 2, 3, 5, 5, 5, 6, 7, 7, 8]
Enter element to search:
5
4

C:\prakashclasses>java Test
[8, 5, 4, 0, 7, 5, 2, 9, 9, 2]
[0, 2, 2, 4, 5, 5, 7, 8, 9, 9]
Enter element to search:
7
6

C:\prakashclasses>java Test
[4, 5, 9, 6, 4, 5, 3, 0, 7, 6]
[0, 3, 4, 4, 5, 5, 6, 6, 7, 9]
Enter element to search:
4
-1

binary search with customized ranges
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Demo{
	static int binarySearchRecursion(int[] a,int key,int low,int high){
			if(low<=high){
				int mid = (low+high)/2;
				if(a[mid]==key)
					return mid;
				else if(a[mid]<key)
					return binarySearchRecursion(a,key,mid+1,high);
				else
					return binarySearchRecursion(a,key,low,mid-1);
			}
			return -1;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println("Enter starting location of search:");
		int start=obj.nextInt();
		System.out.println("Enter ending location of search:");
		int end=obj.nextInt();
		System.out.println(Demo.binarySearchRecursion(a,key,start,end));
	}
}

output:
-------
C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[2, 2, 0, 4, 2, 5, 0, 7, 1, 3]
[0, 0, 1, 2, 2, 2, 3, 4, 5, 7]
Enter element to search:
2
Enter starting location of search:
6
Enter ending location of search:
9
-1

C:\prakashclasses>java Test
[9, 1, 0, 6, 2, 3, 5, 6, 6, 8]
[0, 1, 2, 3, 5, 6, 6, 6, 8, 9]
Enter element to search:
5
Enter starting location of search:
2
Enter ending location of search:
5
4

Arrays.binarySearch() method:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		Random r = new Random();
		int a[] = new int[10];

		for(int i=0;i<10;i++)
			a[i] = r.nextInt(10);

		System.out.println(Arrays.toString(a));
		Arrays.sort(a);
		System.out.println(Arrays.toString(a));
		System.out.println("Enter element to search:");
		int key = obj.nextInt();
		System.out.println(Arrays.binarySearch(a,0,a.length,key));
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
[1, 9, 9, 0, 9, 0, 4, 8, 0, 3]
[0, 0, 0, 1, 3, 4, 8, 9, 9, 9]
Enter element to search:
9
7

C:\prakashclasses>java Test
[5, 7, 5, 6, 3, 6, 0, 4, 6, 6]
[0, 3, 4, 5, 5, 6, 6, 6, 6, 7]
Enter element to search:
7
9

C:\prakashclasses>java Test
[1, 4, 4, 4, 5, 6, 8, 6, 7, 1]
[1, 1, 4, 4, 4, 5, 6, 6, 7, 8]
Enter element to search:
9
-11

Arrays.binarySearch(a,startingloc,endingloc,key);


LINKED LIST DATA STRUCTURE
~~~~~~~~~~~~~~~~~~~~~~~~~~~

the problems with arrays are:

1) size if always fixed.
2) inserting and deleting is very difficult.

to overcome these problems, we have linked list data structure.

linked list:
~~~~~~~~~~~~
it is collection of nodes which are growable. during execution we can insert and delete nodes from linked list. linked list is the best data structure for inserting and deleting elements.

accessing elements ----> best -----> arrays
insert/delete ---------> best -----> linked list

the following are the four types of linked lists are existed in java

1) single linked list
2) double linked list
3) circular single linked list
4) circular double linked list

single linked list
-------------------
01) Inserting the data first         ------------> ok
02) Inserting the data last        --------------> ok
03) Inserting the data at position        -------> ok
04) Sorted Insertion Asc/Desc        ------------> ok
05) Traversing or Displaying        -------------> ok
06) Size or Length of list	   --------------> ok
07) Reverse List        -------------------------> ok
08) Searching        ----------------------------> ok
09) Deleting from first        ------------------> ok
10) Deleting from last        -------------------> ok
11) Delete from position        -----------------> ok
12) Deleting Element       - --------------------> ok
13) Deleting Elements        --------------------> ok
14) Deleting Duplicates        ------------------> ok
15) Copy the reversed list        ---------------> ok
16) Copy of original list        ----------------> ok
17) Comparing two list objects ------------------> ok
18) Finding nth node from begining and ending ---> ok


list ---> 111=>222=>333=>null 

reverse:
--------
list ---> 333=>222=>111=> null

copyreversed:
-------------
list -----> 111=>222=>333=>null
list1 ----> 333=>222=>111=>null


package lists;
public class SLL 
{
	Node head;
	int size;
	class Node{
		int data;
		Node next;
		Node(int data){
			this.data = data;
			this.next = null;
			size++;
		}
		Node(int data,Node next){
			this.data = data;
			this.next = next;
			size++;
		}
	}
	void traverse() {
		if(head==null) {
			System.out.println("SLL is empty");
			return;
		}
		Node currNode = head;
		while(currNode!=null) {
			System.out.print(currNode.data+" => ");
			currNode = currNode.next;
		}
		System.out.println("null");
	}
	void addFirst(int data) {
		Node newNode = new Node(data);
		if(head==null) {
			head = newNode;
			return;
		}
		newNode.next = head;
		head = newNode;
	}
	void addLast(int data) {
		Node newNode = new Node(data);
		if(head==null) {
			head = newNode;
			return;
		}
		Node currNode = head;
		while(currNode.next!=null){
			currNode = currNode.next;
		}
		currNode.next = newNode;
	}
	void addPos(int data, int pos) {
		int i=0;
		Node newNode = new Node(data);
		if(head==null) {
			head = newNode;
			return;
		}
		if(pos<0 || pos>=size-1) {
			System.out.println("out of range");
			return;
		}
		if(pos!=0) {
			Node currNode=head,temp=null;
			while(currNode.next!=null && i<pos) {
				temp = currNode;
				currNode = currNode.next;
				i++;
			}
			temp.next = newNode;
			newNode.next = currNode;
		}
		else {
			newNode.next = head;
			head = newNode;
		}
	}
	void sortedInsertAsc(int data) {
		Node newNode = new Node(data);
		Node currNode = head;
		if(currNode==null || currNode.data > data) {
			newNode.next = head;
			head = newNode;
			return;
		}
		while(currNode.next!=null && currNode.next.data<data)
			currNode = currNode.next;
		newNode.next = currNode.next;
		currNode.next = newNode;
	}
	void sortedInsertDesc(int data) {
		Node newNode = new Node(data);
		Node currNode = head;
		if(currNode==null || currNode.data < data) {
			newNode.next = head;
			head = newNode;
			return;
		}
		while(currNode.next!=null && currNode.next.data>data)
			currNode = currNode.next;
		newNode.next = currNode.next;
		currNode.next = newNode;
	}
	int getSize() {
		return this.size;
	}
	boolean search(int data) {
		Node currNode = head;
		while(currNode!=null) {
			if(currNode.data == data) 
				return true;
			currNode = currNode.next;
		}
		return false;
	}
	void deleteFirst() {
		if(head==null) {
			System.out.println("SLL is empty");
			return;
		}
		size--;
		head = head.next;
	}
	void deleteLast() {
		if(head==null) {
			System.out.println("SLL is empty");
			return;
		}
		if(head.next == null) {
			head = null;
			size--;
			return;
		}
		size--;
		Node temp1=head,temp2=head.next;
		while(temp2.next!=null) {
			temp2 = temp2.next;
			temp1 = temp1.next;
		}
		temp1.next = null;
	}
	void deletePos(int pos) {
		Node temp = head;
		int i=0;
		if(temp==null) {
			System.out.println("SLL is empty");
			return;
		}
		if(pos==0) {
			head=head.next;
			size--;
			return;
		}
		if(pos<0 || pos>=size-1) {
			System.out.println("out of range");
			return;
		}
		while(temp.next!=null && i<pos) {
			if(i==pos-1) {
				temp.next = temp.next.next;
				size--;
				return;
			}
			i++;
			temp=temp.next;
		}
	}
	void deleteElement(int value) {
		Node temp = head;
		if(temp==null) {
			System.out.println("SLL is empty");
			return;
		}
		if(temp.data==value) {
			head = head.next;
			size--;
			return;
		}
		while(temp.next!=null) {
			if(temp.next.data == value) {
				temp.next = temp.next.next;
				size--;
				return;
			}
			temp = temp.next;
		}
	}
	void deleteElements(int value) {
		Node temp = head;
		if(temp==null) {
			System.out.println("SLL is empty");
			return;
		}
		if(temp.data==value) {
			head = head.next;
			size--;
		}
		while(temp.next!=null) {
			if(temp.next.data == value) {
				temp.next = temp.next.next;
				size--;
			}
			if(temp.next!=null)
				temp = temp.next;
		}
	}
	void reverse() {
		Node currNode = head, prev = null, next = null;
		while(currNode!=null) {
			next = currNode.next;
			currNode.next = prev;
			prev = currNode;
			currNode = next;
		}
		head = prev;
	}
	//Note: compulsory the list must be in sorted form
	void removeDuplicates() {
		Node currNode = head;
		while(currNode!=null) {
			if(currNode.next!=null && currNode.data == currNode.next.data) 
				currNode.next = currNode.next.next;
			else
				currNode = currNode.next;
		}
	}
	SLL copyReversed() {
		Node temp1 = null, temp2=null, currNode = head;
		while(currNode!=null) {
			temp2 = new Node(currNode.data,temp1);
			currNode = currNode.next;
			temp1 = temp2;
		}
		SLL obj = new SLL();
		obj.head = temp1;
		return obj;
	}
	SLL copyList() {
		Node headNode = null, tailNode=null, tempNode = null, currNode = head;
		if(currNode==null)
			return null;
		headNode = new Node(currNode.data,null);
		tailNode = headNode;
		currNode = currNode.next;
		while(currNode!=null) {
			tempNode = new Node(currNode.data,null);
			tailNode.next = tempNode;
			tailNode = tempNode;
			currNode = currNode.next;
		}
		SLL obj = new SLL();
		obj.head = headNode;
		return obj;
	}
	boolean compareList(SLL list) {
		Node head1=head,head2=list.head;
		while(head1!=null && head2!=null) {
			if(head1.data!=head2.data)
				return false;
			head1 = head1.next;
			head2 = head2.next;
		}
		if(head1==null && head2==null)
			return true;
		return false;
	}
	int nthNodeFromBegin(int index) {
		if(index>getSize() || index<1)
			return -1;
		int count=0;
		Node currNode = head;
		while(currNode!=null && count<index-1) {
			count++;
			currNode = currNode.next;
		}
		return currNode.data;
	}
	int nthNodeFromEnd(int index) {
		int size = getSize(),sindex;
		if(size!=0 && size<index)
			return -1;
		sindex = size-index+1;
		return nthNodeFromBegin(sindex);
	}
}

double linked list
-------------------
01) Inserting the data first         ------------> ok
02) Inserting the data last        --------------> ok
03) Inserting the data at position        -------> ok
04) Sorted Insertion Asc/Desc        ------------> ok
05) Traversing or Displaying        -------------> ok
06) Size or Length of list	   --------------> ok
07) Reverse List        -------------------------> ok
08) Searching        ----------------------------> ok
09) Deleting from first        ------------------> ok
10) Deleting from last        -------------------> ok
11) Delete from position        -----------------> ok
12) Deleting Element       - --------------------> ok
13) Deleting Elements        --------------------> ok
14) Deleting Duplicates        ------------------> ok
15) Copy the reversed list        ---------------> ok
16) Copy of original list        ----------------> ok
17) Comparing two list objects ------------------> ok

package lists;

public class DLL {
	Node head;
	int size = 0;
	class Node{
		int data;
		Node next;
		Node prev;
		Node(int data,Node next,Node prev){
			this.data = data;
			this.next = next;
			this.prev = prev;
			size++;
		}
	}
	void traverse() {
		if(head==null){
			System.out.println("DLL is empty");return;
		}
		Node currNode = head;
		while(currNode!=null) {
			System.out.print(currNode.data+" ==> ");
			currNode = currNode.next;
		}
		System.out.println("NULL");
	}
	void addFirst(int data) {
		Node newNode = new Node(data,null,null);
		if(head==null)
			head = newNode;
		else {
			head.prev = newNode;
			newNode.next = head;
			head = newNode;
		}
	}
	void addLast(int data) {
		Node newNode = new Node(data,null,null);
		if(head==null)
			head = newNode;
		else {
			Node currNode = head;
			while(currNode.next!=null)
				currNode = currNode.next;
			currNode.next = newNode;
			newNode.prev = currNode;
		}
	}
	void addPos(int data,int pos) {
		int i=0;
		if(pos<0 || pos>=size) {
			System.out.println("out of range");return;
		}
		Node newNode = new Node(data,null,null);
		if(head==null) {
			head = newNode;
			return;
		}
		if(pos!=0) {
			Node currNode = head;
			Node temp=null;
			while(currNode.next!=null && i<pos) {
				temp = currNode;
				currNode = currNode.next;
				i++;
			}
			temp.next = newNode;
			newNode.prev = temp;
			newNode.next = currNode;
			currNode.prev = newNode;
		}
		else {
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
		}
	}
	void sortedInsertAsc(int data) {
		Node newNode = new Node(data,null,null);
		Node currNode = head;
		if(currNode == null) {
			head = newNode;
			return;
		}
		if(currNode.data>data) {
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
			return;
		}
		while(currNode.next!=null && currNode.next.data<data)
			currNode = currNode.next;
		if(currNode.next!=null) {
			newNode.next = currNode.next;
			currNode.next.prev = newNode;
			currNode.next = newNode;
			newNode.prev = currNode;
		}
		else {
			currNode.next = newNode;
			newNode.prev = currNode;
		}
	}
	void sortedInsertDesc(int data) {
		Node newNode = new Node(data,null,null);
		Node currNode = head;
		if(currNode == null) {
			head = newNode;
			return;
		}
		if(currNode.data<data) {
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
			return;
		}
		while(currNode.next!=null && currNode.next.data>data)
			currNode = currNode.next;
		if(currNode.next!=null) {
			newNode.next = currNode.next;
			currNode.next.prev = newNode;
			currNode.next = newNode;
			newNode.prev = currNode;
		}
		else {
			currNode.next = newNode;
			newNode.prev = currNode;
		}
	}
	int getSize() {
		return this.size;
	}
	boolean search(int data) {
		Node temp = head;
		while(temp!=null)
		{
			if(temp.data == data)
				return true;
			temp = temp.next;
		}
		return false;
	}
	boolean compareList(DLL list) {
		Node head1 = head,head2 = list.head;
		while(head1!=null && head2!=null) {
			if(head1.data!=head2.data)
				return false;
			head1 = head1.next;
			head2 = head2.next;
		}
		if(head1==null && head2==null)
			return true;
		return false;
	}
	void reverse() {
		Node temp=null,currNode=head;
		while(currNode!=null) {
			temp = currNode.prev;
			currNode.prev = currNode.next;
			currNode.next = temp;
			currNode = currNode.prev;
		}
		if(temp!=null)
			head = temp.prev;
	}
	void deleteFirst() {
		if(head==null) {
			System.out.println("DLL is empty");
			return;
		}
		size--;
		head = head.next;
		if(head!=null)
			head.prev = null;
	}
	void deleteLast() {
		if(head==null) {
			System.out.println("DLL is empty");return;
		}
		if(head.next==null) {
			head = null;
			size--;
			return;
		}
		size--;
		Node temp = head;
		Node currNode = head.next;
		while(currNode.next!=null) {
			currNode = currNode.next;
			temp = temp.next;
		}
		temp.next = null;	
	}
	void deleteAtPos(int pos) {
		Node temp = head,tempp;
		int i=0;
		if(temp==null) {
			System.out.println("DLL is empty");return;
		}
		if(pos<0 || pos>=getSize()) {
			System.out.println("out of range");return;
		}
		if(pos==0) {
			head=head.next;
			if(head!=null)
				head.prev=null;
			size--;
			return;
		}
		while(temp.next!=null && i<pos) {
			if(i==pos-1) {
				temp.next = temp.next.next;
				tempp = temp.next;
				if(tempp!=null)
					tempp.prev = temp;
				size--;
				return;
			}
			i++;
			temp=temp.next;
		}		
	}
	void deleteElement(int data) {
		Node temp = head,tempp;
		if(temp==null) {
			System.out.println("DLL is empty");return;
		}
		if(temp.data == data) {
			head = head.next;
			if(head!=null)
				head.prev = null;
			size--;
			return;
		}
		while(temp.next!=null) {
			if(temp.next.data == data) {
				temp.next = temp.next.next;
				tempp = temp.next;
				if(tempp!=null)
					tempp.prev = temp;
				size--;
				return;
			}
			temp = temp.next;
		}
	}
	void deleteElements(int data) {
		Node temp = head,tempp;
		if(temp==null) {
			System.out.println("DLL is empty");return;
		}
		if(temp.data == data) {
			head = head.next;
			if(head!=null)
				head.prev = null;
			size--;
			return;
		}
		while(temp.next!=null) {
			if(temp.next.data == data) {
				temp.next = temp.next.next;
				tempp = temp.next;
				if(tempp!=null)
					tempp.prev = temp;
				size--;
			}
			temp = temp.next;
		}
	}
	//list should in order
	void removeDuplicates() {
		Node currNode = head,temp;
		while(currNode!=null) {
			if(currNode.next!=null && currNode.data == currNode.next.data) {
				currNode.next = currNode.next.next;
				temp = currNode.next;
				if(temp!=null)
					temp.prev = currNode;
			}else {
				currNode = currNode.next;
			}
		}
	}
	DLL copyList() {
		Node headNode=null,tailNode,tempNode,currNode=head;
		tailNode = null;
		tempNode = null;
		if(currNode==null)
			return null;
		headNode = new Node(currNode.data,null,null);
		tailNode = headNode;
		currNode = currNode.next;
		while(currNode!=null) {
			tempNode = new Node(currNode.data,null,null);
			tailNode.next = tempNode;
			tempNode.prev = tailNode;
			tailNode = tempNode;
			currNode = currNode.next;
		}
		DLL obj = new DLL();
		obj.head = headNode;
		return obj;
	}
	DLL copyReverse() {
		Node temp1=null,temp2=null,currNode=head;
		while(currNode!=null) {
			temp2 = new Node(currNode.data,temp1,null);
			currNode = currNode.next;
			if(temp1!=null)
				temp1.prev = temp2;
			temp1 = temp2;
		}
		DLL obj = new DLL();
		obj.head = temp1;
		return obj;
	}
}

Circular Single Linked List
~~~~~~~~~~~~~~~~~~~~~~~~~~~
package lists;

public class CSLL {
	Node tail;
	int size = 0;
	class Node{
		int value;
		Node next;
		Node(int value,Node next){
			this.value = value;
			this.next = next;
		}
	}
	void print() {
		if(size==0) {
			System.out.println("CSLL is empty");
			return;
		}
		Node temp = tail.next;
		while(temp!=tail) {
			System.out.print(temp.value+" => ");
			temp = temp.next;
		}
		System.out.println(temp.value);
	}
	void addHead(int value) {
		Node temp = new Node(value,null);
		if(size==0) {
			tail = temp;
			temp.next = temp;
		}
		else {
			temp.next = tail.next;
			tail.next = temp;
		}
		size++;
	}
	void addTail(int value) {
		Node temp = new Node(value,null);
		if(size==0) {
			tail = temp;
			temp.next = temp;
		}
		else {
			temp.next = tail.next;
			tail.next = temp;
			tail = temp;
		}
		size++;
	}
	void addPos(int pos,int value) {
		Node newNode = new Node(value,null);
		if(size==0) {
			tail = newNode;
			newNode.next = newNode;
		}
		else {
			if(pos==0) {
				Node temp = tail.next;
				newNode.next = temp;
				tail.next = newNode;
			}
			else {
				Node temp = tail.next;
				int i=0;
				while(temp.next!=tail && i<pos-1) {
					temp = temp.next;
					i++;
				}
				newNode.next = temp.next;
				temp.next = newNode;
			}			
		}
		size++;
	}
	void removeHead() {
		if(size==0) {
			System.out.println("CSLL is empty");
			return;
		}
		if(tail==tail.next)
			tail = null;
		else 
			tail.next = tail.next.next;
		size--;			
	}
	void removeTail() {
		if(size==0) {
			System.out.println("CSLL is empty");
			return;
		}
		if(tail == tail.next)
			tail = null;
		else {
			Node temp = tail.next;
			while(temp.next!=tail)
				temp = temp.next;
			temp.next = tail.next;
			tail = temp;
		}
		size--;
	}
	void deleteElement(int value) {
		if(size==0) {
			System.out.println("CSLL is empty");
			return;
		}
		Node prev=tail,currNode=tail.next,head=tail.next;
		if(currNode.value == value) {
			if(currNode==currNode.next)
				tail=null;
			else
				tail.next = tail.next.next;
			size--;
			return;
		}
		
			prev = currNode;
			currNode = currNode.next;
			while(currNode!=head) {
				if(currNode.value==value) {
					if(currNode==tail)
						tail=prev;
				prev.next = currNode.next;
				return;
				}
				prev = currNode;
				currNode = currNode.next;
			}
	}
}

Circular Double Linked List
~~~~~~~~~~~~~~~~~~~~~~~~~~~
package lists;

public class CDLL {
	Node head = null;
	Node tail = null;
	int size = 0;
	class Node{
		int value;
		Node next,prev;
		Node(int value,Node next,Node prev){
			this.value = value;
			this.next = next;
			this.prev = prev;
		}
	}
	void print() {
		if(size==0) {
			System.out.println("CDLL is empty");
			return;
		}
		Node temp = tail.next;
		while(temp!=tail) {
			System.out.print(temp.value+" ==> ");
			temp = temp.next;
		}
		System.out.println(temp.value);
	}
	void addHead(int value) {
		Node newNode = new Node(value,null,null);
		if(size==0) {
			tail = head = newNode;
			newNode.next = newNode;
			newNode.prev = newNode;
		}
		else {
			newNode.next = head;
			newNode.prev = head.prev;
			head.prev = newNode;
			newNode.prev.next = newNode;
			head = newNode;
		}
		size++;
	}
	void addTail(int value) {
		Node newNode =new Node(value,null,null);
		if(size==0) {
			tail = head = newNode;
			newNode.next = newNode;
			newNode.prev = newNode;
		}
		else {
			newNode.next = tail.next;
			newNode.prev = tail;
			tail.next = newNode;
			newNode.next.prev = newNode;
			tail=newNode;
		}
		size++;
	}
	void removeHead() {
		if(size==0) {
			System.out.println("CDLL is empty");
			return;
		}
		size--;
		if(size==0) {
			head = null;
			tail=null;
			return;
		}
		Node temp = head.next;
		temp.prev = tail;
		tail.next = temp;
		head = temp;
	}
	void removeTail() {
		if(size==0) {
			System.out.println("CDLL is empty");
			return;
		}
		size--;
		if(size==0) {
			head= null;
			tail = null;
		}
		Node temp = tail.prev;
		temp.next = head;
		head.prev = temp;
		tail = temp;
	}
}

package lists;

public class Test 
{
	public static void main(String[] args) 
	{
		CDLL list = new CDLL();
		list.addHead(111);
		list.addTail(222);
		list.addTail(333);
		list.addTail(444);
		list.addTail(555);
		list.addHead(888);
		list.addHead(999);
		list.print();
		list.removeHead();
		list.print();
		list.removeTail();
		list.print();
	}
}


stack data structures:
~~~~~~~~~~~~~~~~~~~~~~
01. Introduction
02. Operations on stack
03. implementation of stack using arrays
04. implementation of stack using linked list
05. predefined implementation stack class (java.util.Stack)
06. toString() method implementation for stack class
07. sorted insertion into stack
08. sorting stack elements
09. bottom insertion 
10. reverse of the stack
11. balanced parethesis application
12. infix, prefix and postfix expressions
13. infix to postfix conversion
14. infix to prefix conversion
15. postfix evaluation

Stack data structure
--------------------

introduction to stack:
~~~~~~~~~~~~~~~~~~~~~~
stack is a linear data structure which follows last-in-first-out LIFO, the item which is inserted at last will be the item removed first. Example, books, bangle, plates etc. 

the following are the common operations that we can able to perform on stack data structures..


1) push() ------> it is used to insert an object into the stack
2) pop() -------> it is used to delete an element from stack
3) peek() ------> it returns top most element from the stack
4) display() ---> list out the objects present in the stack
5) empty() -----> return true if the element is empty else false
6) getSize() ---> return number of elements present in the stack

In this stack, we will use a special pointer to perform insertion/deletion/display/peek called top, the default value for top is always -1. when an object is inserted into the stack first top will be incremented by one unit and then we will push the element. when an obj is removed from the stack first we will decrement top variable by one unit and then delete element.

we can represent stack data structure in the following three ways

1) implementation of stack data structure by using arrays.
2) implementation of stack data structure by using linked list.
3) implementation of stack data structure by util package (java.util.Stack)

implementation of stack data structure by using arrays
------------------------------------------------------
import java.util.*;

class StackArray{
	int size,top,data[];
	StackArray(){
		size = 5;
		top = -1;
		data = new int[size];
	}
	boolean empty(){
		return top==-1;
	}
	int getSize(){
		return top+1;
	}
	void push(int value){
		if(top==size-1)
		{
			System.out.println("stack overflow");
			return;
		}
		top++;
		data[top] = value;
	}
	void pop(){
		if(empty()){
			System.out.println("stack is empty");
			return;
		}
		else{
			System.out.println("deleted item: "+data[top]);
			top--;
		}
	}
	void display(){
		if(empty()){
			System.out.println("stack is empty");
			return;
		}
		else{
			for(int i=0;i<=top;i++)
				System.out.print(data[i]+" ");
			System.out.println();
		}
	}
	int peek(){
		if(empty())
			return -1;
		else
			return data[top];
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		StackArray s = new StackArray();
		System.out.println(s.empty());//true
		s.push(111);
		s.push(222);
		s.push(333);
		s.push(444);
		s.push(555);
		s.display();
		s.pop();//555
		s.pop();//444
		s.display();
		System.out.println(s.peek());
	}
}



implementation of stack data structure by using linked list
-----------------------------------------------------------
import java.util.*;

class StackLL{
	Node head = null;
	int size = 0;
	class Node{
		int value;
		Node next;
		Node(int value,Node next){
			this.value = value;
			this.next = next;
		}
	}
	int getSize(){
		return size;
	}
	boolean isEmpty(){
		return size==0;
	}
	void print(){
		Node temp = head;
		if(temp==null){
			System.out.println("stack is empty");
			return;
		}
		while(temp!=null){
			System.out.print(temp.value+" ");
			temp=temp.next;
		}
		System.out.println();
	}
	void push(int value){
		head = new Node(value,head);
		size++;
	}
	int pop(){
		if(isEmpty()){
			System.out.println("stack is empty");
			return -1;
		}
		int temp=head.value;
		head = head.next;
		size--;
		return temp;
	}
	int peek(){
		if(isEmpty()){
			System.out.println("stack is empty");
			return -1;
		}
		return head.value;
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		StackLL s = new StackLL();
		s.push(111);
		s.push(222);
		s.push(333);
		s.push(444);
		s.print();
		System.out.println(s.peek());//444
		System.out.println(s.pop());//444
		s.print();
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
444 333 222 111
444
444
333 222 111


implementation of stack data structure by util package (java.util.Stack)
------------------------------------------------------------------------
case1: General Implementation of stack class
--------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Stack s = new Stack();
		s.push(111);
		s.push(222);
		s.push(333);
		s.push(444);
		s.push(555);
		System.out.println(s);//[111,222,333,444,555]
		System.out.println(s.peek());//555
		System.out.println(s.pop());//555
		System.out.println(s);//[111,222,333,444]
	}
}

case2: Stack class to hold String class objects
-----------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Stack<String> s = new Stack<String>();
		s.push("AAA");
		s.push("BBB");
		s.push("CCC");
		s.push("DDD");
		s.push("EEE");
		System.out.println(s);//[AAA,BBB,CCC,DDD,EEE]
		System.out.println(s.peek());//EEE
		System.out.println(s.pop());//EEE
		System.out.println(s);//[AAA,BBB,CCC,DDD]
	}
}

case3: Stack class to hold student class objects
-------------------------------------------------
import java.util.*;

class Student{
	int id;
	String name;
	Student(String name,int id){
		this.id = id;
		this.name = name;
	}
	public String toString(){
		return "("+this.id+","+this.name+")";
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student("AAA",111);
		Student s2 = new Student("BBB",333);
		Student s3 = new Student("CCC",555);
		Student s4 = new Student("DDD",222);
		Student s5 = new Student("EEE",444);

		Stack<Student> s = new Stack<Student>();
		s.push(s1);
		s.push(s2);
		s.push(s3);
		s.push(s4);
		s.push(s5);
		System.out.println(s);//[AAA,BBB,CCC,DDD,EEE]
		System.out.println(s.peek());//EEE
		System.out.println(s.pop());//EEE
		System.out.println(s);//[AAA,BBB,CCC,DDD]
	}
}

C:\prakashclasses>java Test
[(111,AAA), (333,BBB), (555,CCC), (222,DDD), (444,EEE)]
(444,EEE)
(444,EEE)
[(111,AAA), (333,BBB), (555,CCC), (222,DDD)]


toString() method implementation for stack class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;

class StackArray{
	int size,top,data[];
	StackArray(){
		size = 5;
		top = -1;
		data = new int[size];
	}
	boolean empty(){
		return top==-1;
	}
	int getSize(){
		return top+1;
	}
	void push(int value){
		if(top==size-1)
		{
			System.out.println("stack overflow");
			return;
		}
		top++;
		data[top] = value;
	}
	void pop(){
		if(empty()){
			System.out.println("stack is empty");
			return;
		}
		else{
			System.out.println("deleted item: "+data[top]);
			top--;
		}
	}
	void display(){
		if(empty()){
			System.out.println("stack is empty");
			return;
		}
		else{
			for(int i=0;i<=top;i++)
				System.out.print(data[i]+" ");
			System.out.println();
		}
	}
	int peek(){
		if(empty())
			return -1;
		else
			return data[top];
	}

	public String toString(){
		StringBuilder sb = new StringBuilder();
		sb.append("[");
		for(int i=0;i<top;i++)
			sb.append(data[i]+", ");
		sb.append(data[top]);
		sb.append("]");
		return sb.toString();
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		StackArray s = new StackArray();
		s.push(111);
		s.push(222);
		s.push(333);
		s.push(444);
		s.push(555);
		System.out.println(s);
	}
}

C:\prakashclasses>java Test
[111, 222, 333, 444, 555]

sorted insertion into stack
~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Test 
{
	public static void sortedInsert(Stack<Integer> ss,int value){
		int temp;
		if(ss.empty()||value>ss.peek())
			ss.push(value);
		else{
			temp = ss.pop();
			sortedInsert(ss,value);
			ss.push(temp);
		}
	}
	public static void main(String[] args) 
	{
		Stack s = new Stack();
		s.push(1);
		s.push(3);
		s.push(4);
		System.out.println(s);//[1,3,4]
		sortedInsert(s,2);
		System.out.println(s);//[1,2,3,4]
	}
}


C:\prakashclasses>java Test
[1, 3, 4]
[1, 2, 3, 4]

sorting stack elements
~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Test 
{
	public static void sortedInsert(Stack<Integer> ss,int value){
		int temp;
		if(ss.empty()||value>ss.peek())
			ss.push(value);
		else{
			temp = ss.pop();
			sortedInsert(ss,value);
			ss.push(temp);
		}
	}
	static void sortStack(Stack<Integer> ss){
		int temp;
		if(ss.empty()==false){
			temp = ss.pop();
			sortStack(ss);
			sortedInsert(ss,temp);
		}
	}
	public static void main(String[] args) 
	{
		Stack s = new Stack();
		s.push(1);
		s.push(3);
		s.push(4);
		s.push(2);
		s.push(5);
		System.out.println(s);//[1,3,4,2,5]
		sortStack(s);
		System.out.println(s);//[1,2,3,4,5]
	}
}

bottom insertion 
----------------
import java.util.*;
class Test 
{
	static void bottomInsert(Stack<Integer> ss,int value){
		int temp;
		if(ss.empty())
			ss.push(value);
		else{
			temp = ss.pop();
			bottomInsert(ss,value);
			ss.push(temp);
		}
	}
	public static void main(String[] args) 
	{
		Stack s = new Stack();
		s.push(1);
		s.push(2);
		s.push(3);
		System.out.println(s);//[1,2,3]
		bottomInsert(s,888);
		System.out.println(s);//[888,1,2,3]
		bottomInsert(s,999);
		System.out.println(s);//[999,888,1,2,3]
	}
}

reverse of the stack
--------------------
import java.util.*;
class Test 
{
	static void bottomInsert(Stack<Integer> ss,int value){
		int temp;
		if(ss.empty())
			ss.push(value);
		else{
			temp = ss.pop();
			bottomInsert(ss,value);
			ss.push(temp);
		}
	}
	static void reverseStack(Stack<Integer> ss){
		int temp;
		if(ss.empty())
			return;
		else{
			temp = ss.pop();
			reverseStack(ss);
			bottomInsert(ss,temp);
		}
	}
	public static void main(String[] args) 
	{
		Stack s = new Stack();
		s.push(1);
		s.push(5);
		s.push(3);
		s.push(4);
		s.push(2);
		System.out.println(s);//[1,5,3,4,2]
		reverseStack(s);
		System.out.println(s);//[2,4,3,5,1]
	}
}

balanced parethesis application
-------------------------------
() 		valid
(){}	valid
([{}])	valid
([})	invalid

import java.util.*;
class Test 
{
	static boolean isBalancedParenthesis(String exp){
		Stack<Character> s = new Stack<Character>();
		for(char ch:exp.toCharArray()){
			switch(ch){
			case '(': s.push(ch); break;
			case '[': s.push(ch); break;
			case '{': s.push(ch); break;

			case ')': 
					  if(s.pop()!='('){
					  	return false;
					  }
					  break;
			case ']': 
					  if(s.pop()!='['){
					  	return false;
					  }
					  break;
			case '}': 
					  if(s.pop()!='{'){
					  	return false;
					  }
					  break;
			}
		}
		return s.empty();
	}
	public static void main(String[] args) 
	{
		System.out.println(isBalancedParenthesis("[]"));//true
		System.out.println(isBalancedParenthesis("[](){}"));//true
		System.out.println(isBalancedParenthesis("[{}]"));//true
		System.out.println(isBalancedParenthesis("[{)]"));//false
	}
}

12. infix, prefix and postfix expressions
-----------------------------------------
expression is a combination of operators and operands. The expressions in any programming language are classified into three types.

1) infix expressions -----> operand OPERATOR operand
2) prefix expressions ----> OPERATOR operand operand
3) postfix expressions ---> operand operand OPERATOR

Ex1:
	infix	:   a+b
	prefix	:  	+ab
	postfix	: 	ab+

Ex2:

	infix	:	a*b+c
	prefix	:	+*abc
	postfix	:	ab*c+

Ex3:

	infix	: 	a+b*c
	prefix	:	+a*bc
	postfix	:	abc*+

13. infix to postfix conversion
-------------------------------

Infix to Postfix Conversion:
----------------------------

Ex1: a+b

input ----> a,+,b
stack ----> +
output ---> ab+

postfix: ab+

Ex2: a*b+c

input -----> a, *, b, +, c
stack -----> *, +
output ----> ab*c+

postfix: ab*c+

Ex3: a+b*c

input -----> a, +, b, *, c
stack -----> +,*
output ----> abc*+

postfix: abc*+

Ex4: a+b/c-d

input -----> a, +, b, /, c, -, d
stack -----> +,/
output ----> abc/d-+

postfix: abc/d-+

Ex5: a+b-c

input ------> a, +, b, -, c
stack ------> +,-
output -----> abc-+

postfix: abc-+

Infix to Postfix Conversion Algorithm:
--------------------------------------
1. read the given expression from left to right.
2. if the input symbol is '(' then push it in to the stack.
3. if the input symbol is opeand, then add it into the output.
4. if the input symbol is operator, then
   a) check the precedence of an operator which is existed inside the stack is having greater priority when compared with incoming operator precedence, then remove that operator from stack and put it into the output, repeat this process until you get the operator which is having less priority.
   b) otherwise push that incoming operator into stack.
5. if the input symbol is ')' then pop all operators from stack, place them into output till the '(' is encounerted, dn't push parenthisis into output.
6. if all the symbols are extracted then pop all the remaining operators from stack and push it into the output.
7. finally print output.

Infix to Postfix Conversion Implementation:
-------------------------------------------
import java.util.*;
class Test 
{
	static int precedence(char ch){
		if(ch=='+'||ch=='-')
			return 1;
		if(ch=='*'||ch=='/')
			return 2;
		return -1;
	}
	static String infixToPostfix(String exp){
		String output="";
		Stack<Character> stack = new Stack<Character>();
		for(int i=0;i<exp.length();i++){
			char ch = exp.charAt(i);
			if(Character.isLetterOrDigit(ch))
				output=output+ch;
			else if(ch=='(')
				stack.push(ch);
			else if(ch==')'){
				while(!stack.empty() && stack.peek()!='('){
					output=output+stack.peek();
					stack.pop();
				}
				stack.pop();
			}
			else{
				while(!stack.empty() && precedence(ch)<precedence(stack.peek())){
					output=output+stack.peek();
					stack.pop();
				}
				stack.push(ch);
			}
		}
		while(!stack.empty())
		{
			output=output+stack.peek();
			stack.pop();
		}
		return output;
	}
	public static void main(String[] args) 
	{
		System.out.println(infixToPostfix("a+b"));//ab+
		System.out.println(infixToPostfix("a*b+c"));//ab*c+
	}
}

14. infix to prefix conversion
------------------------------

infix to prefix conversion examples:
------------------------------------
Ex1:
	expression: a+b

	1) reverse         ----> b+a
	2) infix to postfix ---> ba+
	3) reverse result -----> +ab

	prefix: +ab

Ex2:
----
	expression: a+b*c

	1) reverse ----------> c*b+a
	2) infix to postfix -> cb*a+
	3) reverse result ---> +a*bc

	prefix: +a*bc

infix to prefix conversion algorithm:
-------------------------------------

Algorithm:
----------
1) reverse the given input expression
2) apply infix to postfix conversion
3) reverse the output expression

infix to prefix conversion implementation:
------------------------------------------
import java.util.*;
class Test 
{
	static int precedence(char ch){
		if(ch=='+'||ch=='-')
			return 1;
		if(ch=='*'||ch=='/')
			return 2;
		return -1;
	}
	static String infixToPostfix(String exp){
		String output="";
		Stack<Character> stack = new Stack<Character>();
		for(int i=0;i<exp.length();i++){
			char ch = exp.charAt(i);
			if(Character.isLetterOrDigit(ch))
				output=output+ch;
			else if(ch=='(')
				stack.push(ch);
			else if(ch==')'){
				while(!stack.empty() && stack.peek()!='('){
					output=output+stack.peek();
					stack.pop();
				}
				stack.pop();
			}
			else{
				while(!stack.empty() && precedence(ch)<precedence(stack.peek())){
					output=output+stack.peek();
					stack.pop();
				}
				stack.push(ch);
			}
		}
		while(!stack.empty())
		{
			output=output+stack.peek();
			stack.pop();
		}
		return output;
	}
	public static String infixToPrefix(String s){
		String output = new String();
		output = new StringBuffer(s).reverse().toString();
		output = infixToPostfix(output);
		output = new StringBuffer(output).reverse().toString();
		return output;
	}
	public static void main(String[] args) 
	{
		System.out.println("a+b");//ab+
		System.out.println(infixToPostfix("a+b"));//ab+
		System.out.println(infixToPrefix("a+b"));//+ab
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
a+b
ab+
+ab

15. postfix evaluation
~~~~~~~~~~~~~~~~~~~~~~
The postfix notation is used to represent algebric expr. the expression written in postfix form are evalauted faster when compared with infix notations. as parenthesis is not required in postfix notation.

steps:
------
1) create a stack to store operands (or values).
2) scan the given expression from left to right and do the following for every scanned element
   a) if the element is a number, push it into the stack.
   b) if the element is an operator, pop operands for the operator from stack. evaluate the operator and push the result back into stack.
3) when the expression is ended, the number in the stack is the final result.

Ex1: 2+3

infix: 2+3
postfix: 23+
result: 5

Ex2: 2+3-1

infix: 2+3-1
postfix: 23+1-
result: 4

implementation:
---------------
import java.util.*;
class Test 
{
	static int precedence(char ch){
		if(ch=='+'||ch=='-')
			return 1;
		if(ch=='*'||ch=='/')
			return 2;
		return -1;
	}
	static String infixToPostfix(String exp){
		String output="";
		Stack<Character> stack = new Stack<Character>();
		for(int i=0;i<exp.length();i++){
			char ch = exp.charAt(i);
			if(Character.isLetterOrDigit(ch))
				output=output+ch;
			else if(ch=='(')
				stack.push(ch);
			else if(ch==')'){
				while(!stack.empty() && stack.peek()!='('){
					output=output+stack.peek();
					stack.pop();
				}
				stack.pop();
			}
			else{
				while(!stack.empty() && precedence(ch)<precedence(stack.peek())){
					output=output+stack.peek();
					stack.pop();
				}
				stack.push(ch);
			}
		}
		while(!stack.empty())
		{
			output=output+stack.peek();
			stack.pop();
		}
		return output;
	}
	static int evalPostfix(String s){
		Stack<Integer> stack = new Stack<Integer>();
		for(int i=0;i<s.length();i++){
			char ch = s.charAt(i);
			if(Character.isDigit(ch))
				stack.push(ch-'0');
			else{
				int v1 = stack.pop();
				int v2 = stack.pop();
				switch(ch){
				case '+': stack.push(v2+v1);break;
				case '-': stack.push(v2-v1);break;
				case '*': stack.push(v2*v1);break;
				case '/': stack.push(v2/v1);break;
				}
			}
		}
		return stack.pop();
	}
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		String s = obj.nextLine();
		System.out.println(s);
		System.out.println(infixToPostfix(s));
		System.out.println(evalPostfix(infixToPostfix(s)));
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
2+3
2+3
23+
5

C:\prakash>java Test
2+3-1
2+3-1
231-+
4

C:\prakash>java Test
2*3-1
2*3-1
23*1-
5

Queue data structure:
~~~~~~~~~~~~~~~~~~~~~
It is a linear data structure which follows FIFO method, first-in-first-out method. The item which is inserted first will be the item which is remove first/accessed first. we will maintain two pointer to work with queue data structure i.e. front and rear. front variable will be incremented by one unit, when item is deleted from the queue and rear variable will be incremented by one unit, when item is inserted into the queue. the following are the different types of queues supported by data structures.

1) normal queue
2) circular queue
3) dequeue

The following are the various operations that we can able to perform on the queue.

1) inserting an element into queue
2) deleteing an element from queue
3) displaying all the elements in queue.

normal queue implementation by using arrays:
--------------------------------------------
import java.util.*;

class NQ{
	int front,rear,size;
	int Q[];
	NQ(){
		front = -1;
		rear = -1;
		size = 5;
		Q = new int[5];
	}
	void insert(int value){
		if(rear==size){
			System.out.println("Q is full");
			return;
		}
		if(front==rear)
			front=rear=0;
		Q[rear++]=value;
	}
	void delete(){
		if(front==rear){
			System.out.println("Q is empty");
			return;
		}
		System.out.println("deleted item is: "+Q[front]);
		front++;
		if(front==rear)
			front=rear=-1;
	}
	void display(){
		if(front==rear){
			System.out.println("Q is empty");
			return;
		}
		for(int i=front;i<rear;i++){
			System.out.print(Q[i]+" ");
		}
		System.out.println();
	}
}

class Test 
{	
	public static void main(String[] args) 
	{
		NQ q = new NQ();
		q.insert(111);
		q.insert(222);
		q.insert(333);
		q.insert(444);
		q.insert(555);
		q.display();
		q.insert(666);//Q is fulle
		q.delete();//111
		q.display();
	}
}


C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
111 222 333 444 555
Q is full
deleted item is: 111
222 333 444 555

normal queue implementation by using linked list
------------------------------------------------
import java.util.*;

class NQList{
	Node front, rear;
	int size;
	NQList(){
		front = null;
		rear = null;
		size = 0;
	}
	class Node{
		int value;
		Node next;
		Node(int value,Node next){
			this.value = value;
			this.next = next;
		}
	}
	boolean empty(){
		return size==0;
	}
	void insert(int value){
		Node newNode = new Node(value,null);
		if(front==null && rear==null){
			front = newNode;
			rear = newNode;
		}
		else{
			rear.next = newNode;
			rear = newNode;
		}
		size++;
	}
	void delete(){
		if(empty()){
			System.out.println("Q is empty");
			return;
		}
		System.out.println("Deleted value: "+front.value);
		front = front.next;
		size--;
	}
	void display(){
		if(empty()){
			System.out.println("Q is empty");
			return;
		}
		Node temp = front;
		while(temp!=null){
			System.out.print(temp.value+" ");
			temp = temp.next;
		}
		System.out.println();
	}
}

class Test 
{	
	public static void main(String[] args) 
	{
		NQList q = new NQList();
		q.insert(111);
		q.insert(222);
		q.insert(333);
		q.insert(444);
		q.insert(555);
		q.insert(666);
		q.display();
		q.delete();//111
		q.display();
		q.delete();//222
		q.display();
	}
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
111 222 333 444 555 666
Deleted value: 111
222 333 444 555 666
Deleted value: 222
333 444 555 666



circular queue:
~~~~~~~~~~~~~~~
There is a problem with normal queue, even though there are some empty positiosn inside queue it displays saying "Q is full". to overcome this problem, we are going for circular queue. Circular queue will attached last and first element in a circular manner.

circular queue implementation by using arrays:
----------------------------------------------
import java.util.*;

class CQArrays{
	int front,rear,size,Q[],c;
	CQArrays(){
		front = -1;
		rear = -1;
		size = 5;
		c = 0;
		Q = new int[size];
	}
	void insert(int value){
		if(c==size){
			System.out.println("CQ is full");
			return;
		}
		if(c==0)
			front=rear=0;
		else
			rear = (rear+1)%size;
		Q[rear] = value;
		c++;
	}
	void delete(){
		if(c==0){
			System.out.println("CQ is empty");
			return;
		}
		System.out.println("Deleted item is: "+Q[front]);
		if(front==rear)
			front=rear=-1;
		else
			front=(front+1)%size;
		c--;
	}
	void display(){
		if(c==0){
			System.out.println("Q is empty");
			return;
		}
		int i=front;
		if(front<rear){
			while(i<=rear)
				System.out.print(Q[i++]+" ");
		}
		else{
			while(i!=rear){
				System.out.print(Q[i]+" ");
				i=(i+1)%size;
			}
			System.out.print(Q[i]);
		}
		System.out.println();
	}
}

class Test 
{		
	public static void main(String[] args) 
	{
		CQArrays q = new CQArrays();
		q.insert(111);
		q.insert(222);
		q.insert(333);
		q.insert(444);
		q.insert(555);
		q.display();
		q.insert(666);
		q.delete();
		q.insert(666);
		q.display();
	}	
}


C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
111 222 333 444 555
CQ is full
Deleted item is: 111
222 333 444 555 666


circular queue implementation by using linked list
--------------------------------------------------
import java.util.*;

class CQList{
	Node front;
	Node rear;
	class Node{
		int value;
		Node next;
		Node(int value,Node next){
			this.value = value;
			this.next = next;
		}
	}
	void display(){
		if(front==null){
			System.out.println("CQ is empty");
			return;
		}
		Node temp = front;
		while(temp.next!=front){
			System.out.print(temp.value+" ");
			temp = temp.next;
		}
		System.out.println(temp.value);
	}
	void insert(int value){
		Node newNode = new Node(value,null);
		if(front==null){
			front = newNode;
		}
		else{
			rear.next = newNode;
		}
		rear = newNode;
		rear.next = front;
	}
	void delete(){
		if(front==null){
			System.out.println("Queue is empty");
			return;
		}
		System.out.println("Deleted obj is: "+front.value);
		if(front==rear){
			front=null;
			rear=null;
		}
		else{
			front = front.next;
			rear.next = front;
		}
	}
}

class Test 
{		
	public static void main(String[] args) 
	{
		CQList q = new CQList();
		q.insert(111);
		q.insert(222);
		q.insert(333);
		q.insert(444);
		q.insert(555);
		q.display();
		q.delete();
		q.display();
	}	
}

C:\prakashclasses>javac Test.java

C:\prakashclasses>java Test
111 222 333 444 555
Deleted obj is: 111
222 333 444 555

Deque implementation:
---------------------
Deque stands for double ended queue, i.e. we can perform both insertion and deletions from both ends.

insert ====> insert at front and insert at rear
delete ====> delete from front and deletion from rear

Deque implementation by using arrays:
-------------------------------------
import java.util.Scanner;
class DequeArrays
{
	int dq[],front,rear,size;
	DequeArrays(){
		front = -1;
		rear = -1;
		size = 5;
		dq = new int[size];
	}
	void insertAtFront(int value){
		if((front==0&&rear==size-1)||(front==rear+1)){
			System.out.println("Deque is full");
			return;
		}
		if(front==-1)
			front=rear=0;
		else if(front==0)
			front=size-1;
		else
			front = front-1;
		dq[front]=value;
	}
	void insertAtRear(int value){
		if((front==0&&rear==size-1)||(front==rear+1)){
			System.out.println("Dq is full");
			return;
		}
		if(front==-1)
			front=rear=0;
		else if(rear==size-1)
			rear=0;
		else
			rear=rear+1;
		dq[rear]=value;
	}
	void deleteAtFront(){
		if(front==-1){
			System.out.println("dq is empty");
			return;
		}
		System.out.println("deleted object from dq is "+dq[front]);
		if(front==rear)
			front=rear=-1;
		else{
			if(front==size-1)
				front=0;
			else
				front=front+1;
		}
	}
	void deleteAtRear(){
		if(front==-1){
			System.out.println("dq is empty");
			return;
		}
		System.out.println("Deleted item is "+dq[rear]);
		if(front==rear)
			front=rear=-1;
		else{
			if(rear==0)
				rear=size-1;
			else
				rear=rear-1;
		}
	}
	void display(){
		if(front==-1){
			System.out.println("dq is empty");
			return;
		}
		int left=front,right=rear;
		if(left<=right){
			while(left<=right)
				System.out.print(dq[left++]+" ");
		}
		else{
			while(left<=size-1)
				System.out.print(dq[left++]+" ");
			left=0;
			while(left<=right)
				System.out.print(dq[left++]+" ");
		}
		System.out.println();
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		DequeArrays q = new DequeArrays();
		q.display();//dq is empty
		q.insertAtFront(111);
		q.insertAtFront(222);
		q.insertAtFront(333);
		q.insertAtRear(555);
		q.insertAtRear(444);
		q.insertAtRear(666);//dq is full
		q.display();//333,222,111,555,444
		q.deleteAtFront();//333
		q.display();//222,111,555,444
		q.deleteAtRear();//444
		q.display();//222,111,555
		q.deleteAtRear();//555
		q.deleteAtRear();//111
		q.deleteAtRear();//222
		q.display();//dq is empty
		q.deleteAtFront();//dq is empty
	}
}

C:\DSAJ>javac Test.java

C:\DSAJ>java Test
dq is empty
Dq is full
333 222 111 555 444
deleted object from dq is 333
222 111 555 444
Deleted item is 444
222 111 555
Deleted item is 555
Deleted item is 111
Deleted item is 222
dq is empty
dq is empty

deque implementation by using linked list
-----------------------------------------
class Dqlist
{
	Node front, rear;
	int size;
	Dqlist(){
		front = null;
		rear = null;
		size = 0;
	}
	class Node
	{
		int data;
		Node next;
		Node(int data, Node next)
		{
			this.data = data;
			this.next = next;
		}
	}
	void insertAtFront(int data){
		Node newNode = new Node(data,null);
		if(front==null){
			front = newNode;
			rear = newNode;
			size++;
			return;
		}
		newNode.next = front;
		front = newNode;
		size++;
	}
	void insertAtRear(int data){
		Node newNode = new Node(data,null);
		if(front==null){
			front=newNode;
			rear=newNode;
			size++;
			return;
		}
		rear.next = newNode;
		rear = newNode;
	}
	void deleteFromFront(){
		if(front==null){
			System.out.println("Q is empty");
			return;
		}
		System.out.println("deleted item is:"+front.data);
		front=front.next;
	}
	void deleteFromRear(){
		if(front==null){
			System.out.println("Q is empty");
			return;
		}
		System.out.println("deleted item is :"+rear.data);
		if(front==rear){
			front=null;
			rear=null;
			return;
		}
		Node temp = front;
		while(temp.next!=rear){
			temp = temp.next;
		}
		rear = temp;
		rear.next = null;
	}
	void display(){
		if(front==null){
			System.out.println("q is empty");return;
		}
		Node temp = front;
		while(temp!=null){
			System.out.print(temp.data+" ");
			temp=temp.next;
		}
		System.out.println();
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Dqlist q = new Dqlist();
		q.insertAtFront(111);
		q.insertAtFront(999);
		q.display();//
		q.insertAtRear(444);
		q.insertAtRear(555);
		q.display();
		q.deleteFromFront();//999
		q.deleteFromRear();//555
		q.display();
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
999 111
999 111 444 555
deleted item is:999
deleted item is :555
111 444

predefined queue implementation:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Collection(I) ----> Queue(I)

Queue(I) --------> PriorityQueue(C)
Queue(I) --------> BlockingQueue(I)
Queue(I) --------> Deque(I)

Queue:
------
==> 1.5 version
==> child interface to collection
==> not index based
==> insertion order is based on FIFO method (First-In-First-Out)
==> duplicates are allowed.
==> only homogeneous objects are allowed.
==> only comparable objects, if we want non-comparable object, then comparator

methods:
--------
boolean offer(obj) ---> adds an element to queue
Object peek() --------> read head/first element, if not 'null'
Object element() -----> read head/first element, if not runtime error

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		q.offer(111);
		q.offer(222);
		q.offer(444);
		q.offer(333);
		System.out.println(q);//[111,222,444,333]
	}
}

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		q.offer(111);
		q.offer(222);
		q.offer(444);
		q.offer(333);
		System.out.println(q);//[111,222,444,333]
		System.out.println(q.peek());//111
		System.out.println(q.element());//111
	}
}

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		System.out.println(q.peek());//null
		System.out.println(q.element());//RE:NoSuchElementExceotion
	}
}

Object poll() ----> remove and return head/first element
Object remove() --> remove and return head/first element

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		q.offer(111);
		q.offer(222);
		q.offer(333);
		System.out.println(q);//[111,222,333]
		System.out.println(q.poll());//111
		System.out.println(q);//[222,333]
		System.out.println(q.remove());//222
		System.out.println(q);//[333]
	}
}

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		System.out.println(q.poll());//null
		System.out.println(q.remove());//RE: NoSuchElementException
	}
}

How internally PriorityQueue will work?
---------------------------------------
ans: based on heap concept

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Queue q = new PriorityQueue();
		System.out.println(q);//[]
		q.offer(1);
		q.offer(3);
		q.offer(5);
		q.offer(2);
		q.offer(4);
		System.out.println(q);//[1, 2, 5, 3, 4]
	}
}

Deque:
------
1) introduced in 1.6 version.
2) child interface to Queue interface.
3) deque means double ended queue.
4) deque allows insertions and deletions from both ends.

methods:
--------
void addFirst(obj)      ----> add obj at front
boolean offerFirst(obi) ----> add obj at front

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque q = new ArrayDeque();
		System.out.println(q);//[]
		q.addFirst(111);
		q.addFirst(222);
		q.addFirst(333);
		System.out.println(q);//[333,222,111]
	}
}

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque q = new ArrayDeque();
		System.out.println(q);//[]
		q.offerFirst(111);
		q.offerFirst(222);
		q.offerFirst(555);
		System.out.println(q);//[555,222,111]
	}
}

What is the difference between addFirst() and offerFirst() methods?
-------------------------------------------------------------------
addFirst() method and offerFirst(), will add the object at the begining of queue, for fixed size of deque, offerFirst() will return boolean value.

Object addLast(obj) ----> add the given obj at last
boolean offerLast(obj) -> add the given obj at last

What is the difference between addLast() and offerLast() methods?
-------------------------------------------------------------------
addLast() method and offerLast(), will add the object at the end of queue, for fixed size of deque, offerLast() will return boolean value.

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque q = new ArrayDeque();
		System.out.println(q);//[]
		q.addLast(111);
		q.addLast(222);
		q.addLast(333);
		System.out.println(q);//[111,222,333]
	}
}

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque q = new ArrayDeque();
		System.out.println(q);//[]
		q.offerLast(111);
		q.offerLast(444);
		q.offerLast(999);
		System.out.println(q);//[111,444,999]
	}
}

Object getFirst() -----> return first element from deque
Object peekFirst() ----> return first element from deque
Object getLast() ------> return last element from deque
Object peekLast() -----> return last element from deque

getFirst(), if elements are not existed, then returns NoSuchElementException
peekFirst(), if element is not existed, then returns null
getLast(), if elements are not existed, then returns NoSuchElementException
peekLast(), if element is not existed, then returns null

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque q = new ArrayDeque();
		System.out.println(q);//[]
		q.offerLast(111);
		q.offerLast(444);
		q.offerLast(999);
		System.out.println(q);//[111,444,999]
		System.out.println(q.getFirst());//111
		System.out.println(q.peekFirst());//111
		System.out.println(q.getLast());//999
		System.out.println(q.peekLast());//999

		Deque qq = new ArrayDeque();
		System.out.println(qq);//[]
		System.out.println(qq.getFirst());//RE: NSEE
		System.out.println(qq.peekFirst());//null
		System.out.println(qq.getLast());//RE: NSEE
		System.out.println(qq.peekLast());//null
	}
}

removal operation on deque:
---------------------------

Object removeFirst()	remove first element from dq
Object pollFirst()		remove first element from dq

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque dq = new ArrayDeque();
		dq.add("AAA");
		dq.add("BBB");
		dq.add("CCC");
		dq.add("WWW");
		dq.add("XXX");
		System.out.println(dq);//[AAA,BBB,CCC,WWW,XXX]
		System.out.println(dq.removeFirst());//AAA
		System.out.println(dq);//[BBB,CCC,WWW,XXX]
		System.out.println(dq.pollFirst());//BBB
		System.out.println(dq);//[CCC,WWW,XXX]
	}
}

output:
-------
[AAA, BBB, CCC, WWW, XXX]
AAA
[BBB, CCC, WWW, XXX]
BBB
[CCC, WWW, XXX]

What is the difference betwenn removeFirst() and pollFirst()?
-------------------------------------------------------------
On empty deque object, if we call removeFirst() method it raises an exception saying "NoSuchElementException". On empty deque object, if we call pollFirst() method it wn't raise any error, simply it returns null values.

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque dq = new ArrayDeque();
		System.out.println(dq);//[]
		System.out.println(dq.removeFirst());//RE: NoSuchElementException
		System.out.println(dq.pollFirst());//null
	}
}

add() is used to add an obj into the collection
addLast() is used to add an obj at the end in list

Object removeLast() 	it removes last object from the deque
Object pollLast()		it removes last object from the deque

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque dq = new ArrayDeque();
		dq.add("AAA");
		dq.add("BBB");
		dq.add("CCC");
		dq.add("WWW");
		dq.add("XXX");
		System.out.println(dq);//[AAA,BBB,CCC,WWW,XXX]
		System.out.println(dq.removeLast());//XXX
		System.out.println(dq);//[AAA,BBB,CCC,WWW]
		System.out.println(dq.pollLast());//WWW
		System.out.println(dq);//[AAA,BBB,CCC]
	}
}

output:
-------
[AAA, BBB, CCC, WWW, XXX]
XXX
[AAA, BBB, CCC, WWW]
WWW
[AAA, BBB, CCC]

What is the difference between removeLast() and pollLast() methods?
-------------------------------------------------------------------
on empty deque, if we call removeLast() it returns NoSuchElementException msg, on empty deque object if we call pollLast() method, then it returns null value.

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque dq = new ArrayDeque();
		System.out.println(dq);//[]
		System.out.println(dq.pollLast());//null
		System.out.println(dq.removeLast());//RE: NoSuchElementException
	}
}

boolean removeFirstOccurrence(Object) ----> it removes the first occurrence of given ob
boolean removeLastOccurrence(object) ----> it removes the last occurrence of given obj

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Deque dq = new ArrayDeque();
		dq.add("AAA");
		dq.add("BBB");
		dq.add("CCC");
		dq.add("AAA");
		dq.add("DDD");
		dq.add("AAA");
		dq.add("EEE");
		dq.add("AAA");
		System.out.println(dq);//[AAA, BBB, CCC, AAA, DDD, AAA, EEE, AAA]
		System.out.println(dq.removeFirstOccurrence("AAA"));
		System.out.println(dq);//[BBB, CCC, AAA, DDD, AAA, EEE, AAA]
		System.out.println(dq.removeLastOccurrence("AAA"));
		System.out.println(dq);//[BBB, CCC, AAA, DDD, AAA, EEE]
	}
}

output:
-------
[AAA, BBB, CCC, AAA, DDD, AAA, EEE, AAA]
true
[BBB, CCC, AAA, DDD, AAA, EEE, AAA]
true
[BBB, CCC, AAA, DDD, AAA, EEE]


Bit manipulations:
~~~~~~~~~~~~~~~~~~
01. Introduction to number systems
02. Types of number systems
03. Decimal to Binary conversion
04. Binary to Decimal conversion
05. Bitwise operators
06. Even or Odd number application
07. Swaping of two numbers application
08. Bit level operations (get, set, clear and update)
09. Clear last 'i' bits
10. Clear range of bits (i to j)
11. Number is power of two or not application
12. Count set bits applications
13. Fast exponetiation calculation application
14. Increment a value by one unit
15. Conversion from lower case string into upper case
16. Conversion from upper case string into lower case

Introduction to number systems:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A digital system can understand the digits by using the following components.

1) The digit
2) The position of the digit in the number
3) The base of the number system 


Types of number systems:
~~~~~~~~~~~~~~~~~~~~~~~~
The purpose of number systems are used to represent the number in digital systems.

1) Binary Number System
2) Decimal Number System
3) Octal Number System
4) Hexadecimal Number System

Binary Number System:
---------------------
Digits 		:	0 and 1
Base 		:   2

Decimal Number System
---------------------
Digits 		:   0, 1, 2, 3, 4, 5, 6, 7, 8, 9
Base 		:   10

Octal Number System
-------------------
Digits 		:  	0, 1, 2, 3, 4, 5, 6, 7
Base 		:   8

Hexadecimal Number System
-------------------------
Digits 		: 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
Base 		: 	16

Decimal Number 		Binary Number 		Octal Number 		Hexadecimal Number
------------------------------------------------------------------------------
0 					0000 				0 					0
1 					0001 				1 					1
2 					0010 				2 					2
3 					0011 				3 					3
4 					0100 				4 					4
5 					0101 				5 					5
6 					0110 				6 					6
7 					0111 				7 					7
8 					1000 				10 					8
9 					1001 				11 					9
10 					1010  				12 					a
11 					1011 				13 					b
12 					1100 				14 					c
13 					1101 				15 					d
14 					1110 				16 					e
15 					1111 				17 					f

Decimal to Binary Conversion:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method1:
--------
1) divide the given decimal number by '2', where it gives result along with remainder.
2) we have to store these remainders in a container.
3) we have to print the list values which are stored in reverse order.

Ex:
---
	13 ----> 

	13/2 ---> 6 ----> 1
	6/2 ----> 3 ----> 0
	3/2 ----> 1 ----> 1
	1/2 ----> 0 ----> 1

	ans: 1101

Method2:
--------
Find the binary equalent for the given number by using 8-4-2-1 code

Ex:
---
	15 ----> 1111
	13 ----> 1101

Binary to decimal conversion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Method1:
--------
1) read the digits or symbols one by one from right to left.
2) multiply each bit with 2 power x where x = 0,1,2,3....
3) sum of these expression is the decimal number

Ex:
	1010

	0x2^0 = 0
	1x2^1 = 2
	0x2^2 = 0
	1x2^3 = 8
	---------
	       10
	---------

Method2:
--------
By using 8-4-2-1 code

Ex:
	1010 ----> 8+2=10
	1011 ----> 8+2+1=11

Bitwise operators
~~~~~~~~~~~~~~~~~
Bitwise operators are the special operators in almost all the programming languages. These operators are faster and an efficient way to interact with computers to make heavy computation in a linear time because it works directly with bits rather than a level of conversion internally. The following are the various bitwise operators supported by all most all the programming languages.

1) bitwise and &
2) bitwise or |
3) bitwise x-or ^
4) bitwise left shift <<
5) bitwise right sift >>
6) bitwise complement ~

bitwise and &
-------------
it returns 1 if both bits are 1 else 0

truth table
-----------
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int a = 5, b = 9;
		System.out.println(a&b);//1
	}
}

bitwise or | 
------------
it returns 1 if any one bit 1 else 0

truth table
-----------
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int a = 5, b = 9;
		System.out.println(a|b);//13
	}
}

bitwise x-or ^
---------------
it returns 1 if both bits are in different state else returns 0

truth table
-----------
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int a = 5, b = 9;
		System.out.println(a^b);//12
	}
}

bitwise shift operators:
~~~~~~~~~~~~~~~~~~~~~~~~
shift operators are used to shift the bits of a number to left or right direction.

Ex:
---
	n=5
	n ------> 5
	n<<1 ---> 5*2^1 = 5*2=10
	n<<2 ---> 5*2^2 = 5*4=20

a,b ---> a<<b = a*2^b

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int a = 5;
		System.out.println(a);//5
		System.out.println(a<<1);//10
		System.out.println(a<<2);//20
		System.out.println(a<<3);//40
	}
}


Ex:
---
	n=5
	n ------> 5
	n>>1 ---> 5/2^1 = 5/2=2
	n>>2 ---> 5/2^2 = 5/4=1

a,b ---> a>>b = a/2^b

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int a = 5;
		System.out.println(a);//5
		System.out.println(a>>1);//2
		System.out.println(a>>2);//1
		System.out.println(a>>3);//0
	}
}

bitwise complement: 
-------------------
It is represented as ~, i.e. all the bits are inverted, every 0 as 1 and 1 as 0.

formula: ~n = -(n+1)

Ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		System.out.println(~5);//-(5+1)=-6
		System.out.println(~7);//-(7+1)=-8
		System.out.println(~1);//-(1+1)=-2
		System.out.println(~-2);//-(-2+1)=-(-1)=1
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
-6
-8
-2
1

Advantages of bitwise operators
-------------------------------
1) speed
2) space optimization
3) bit manipulation
4) code simplification
5) readability will be improved
6) data encryption

even or odd number application:
-------------------------------

0 		0000
1 		0001
2       0010
3       0011
4       0100
5       0101
6       0110
7       0111
8       1000
9       1001
10      1010


if LBS is 0 then the given number is even
if LSB is 1 then the given number is odd

bitMask = 1

if (n&bitMask)==0 then EVEN else ODD

Ex:
---
import java.util.*;
class Test 
{
	static String evenOrOdd(int n){
		int bitMask = 1;
		if((n&bitMask)==0)
			return "Even Number";
		else
			return "Odd Number";
	}
	public static void main(String[] args) 
	{
		for(int i=0;i<=10;i++){
			System.out.println(i+"\t"+evenOrOdd(i));
		}		
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
0       Even Number
1       Odd Number
2       Even Number
3       Odd Number
4       Even Number
5       Odd Number
6       Even Number
7       Odd Number
8       Even Number
9       Odd Number
10      Even Number

swaping of two numbers:
-----------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		Scanner obj = new Scanner(System.in);
		System.out.println("Enter a value:");
		int a = obj.nextInt();
		System.out.println("Enter b value:");
		int b = obj.nextInt();

		System.out.println("Before swaping   : a= "+a+" and b= "+b);
		a = a^b;
		b = a^b;
		a = a^b;
		System.out.println("After  swaping   : a= "+a+" and b= "+b);
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
Enter a value:
12
Enter b value:
33
Before swaping   : a= 12 and b= 33
After  swaping   : a= 33 and b= 12


bit level operations:
---------------------
getting ith bit from a binary number
setting ith bit in a binary number
clearing ith bit in a binary number
updating ith bit in a binary number

get ith bit:
~~~~~~~~~~~~

Ex:
---
	10 -----> 1010

	0th -----> 0
	1st -----> 1
	2nd -----> 0
	3rd -----> 1

bitMask = 1<<i

if n & bitMask == 0 then 0 else 1

Ex:
---
import java.util.*;
class Test 
{
	public static int getIthBit(int n,int i){
		int bitMask = 1<<i;
		if((n & bitMask) == 0)
			return 0;
		else
			return 1;
	}
	public static void main(String[] args) 
	{
		//19 ---> 10011
		System.out.println(getIthBit(19,0));//1
		System.out.println(getIthBit(19,1));//1
		System.out.println(getIthBit(19,2));//0
		System.out.println(getIthBit(19,3));//0
		System.out.println(getIthBit(19,4));//1
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
1
1
0
0
1

set ith Bit:
------------

Ex:
	19        ----> 10011

	set 0th   ----> 10010 ---> 18
	set 1st ------> 10001 ---> 17 
	set 2nd ------> 10111 ---> 23
	set 3rd ------> 11011 ---> 27
	set 4th ------> 00011 ---> 3


bitmask = 1<<i

formula: n ^ bitmask

Ex:
---
import java.util.*;
class Test 
{
	public static int getIthBit(int n,int i){
		int bitMask = 1<<i;
		if((n & bitMask) == 0)
			return 0;
		else
			return 1;
	}
	public static int setIthBit(int n,int i){
		int bitMask = 1<<i;
		return n ^ bitMask;
	}
	public static void main(String[] args) 
	{
		//19 ---> 10011
		System.out.println(setIthBit(19,0));//18
		System.out.println(setIthBit(19,1));//17
		System.out.println(setIthBit(19,2));//23
		System.out.println(setIthBit(19,3));//27
		System.out.println(setIthBit(19,4));//3
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
18
17
23
27
3

clear ith bit:
-------------

bitMask = ~(1<<i)

formula : n & bitMask


Ex:
---
import java.util.*;
class Test 
{
	public static int getIthBit(int n,int i){
		int bitMask = 1<<i;
		if((n & bitMask) == 0)
			return 0;
		else
			return 1;
	}
	public static int setIthBit(int n,int i){
		int bitMask = 1<<i;
		return n ^ bitMask;
	}
	public static int clearIthBit(int n,int i){
		int bitMask = ~(1<<i);
		return n&bitMask;
	}
	public static void main(String[] args) 
	{
		//19 ---> 10011
		System.out.println(clearIthBit(19,0));//10011=>10010=>18
		System.out.println(clearIthBit(19,1));//10011=>10001=>17
		System.out.println(clearIthBit(19,2));//10011=>10011=>19
		System.out.println(clearIthBit(19,3));//10011=>10011=>19
		System.out.println(clearIthBit(19,4));//10011=>00011=>3
	}
}

update ith bit:
---------------
import java.util.*;
class Test 
{
	public static int getIthBit(int n,int i){
		int bitMask = 1<<i;
		if((n & bitMask) == 0)
			return 0;
		else
			return 1;
	}
	public static int setIthBit(int n,int i){
		int bitMask = 1<<i;
		return n ^ bitMask;
	}
	public static int clearIthBit(int n,int i){
		int bitMask = ~(1<<i);
		return n&bitMask;
	}
	public static int updateIthBit(int n,int i,int nb){
		if(nb==0)
			return clearIthBit(n,i);
		else
			return n;
	}

	public static void main(String[] args) 
	{
		//19 ---> 10011
		System.out.println(updateIthBit(19,0,0));//10011=>10010=>18
		System.out.println(updateIthBit(19,0,1));//10011=>10011=>19
		System.out.println(updateIthBit(19,1,0));//10011=>10001=>17
		System.out.println(updateIthBit(19,1,1));//10011=>10011=>19
	}
}

clear last i bits:
------------------
19 -----> 10011

clear 1 -----> 10010
clear 2 -----> 10000
clear 3 -----> 10000
clear 4 -----> 10000
clear 5 -----> 00000


bitmask =(-1) << i

formula: n & bitmask

Ex:
---
import java.util.*;
class Test 
{
	public static int clearLastIBits(int n,int i){
		int bitMask = (-1)<<i;
		return n & bitMask;
	}
	public static void main(String[] args) 
	{
		//19 ---> 10011
		System.out.println(clearLastIBits(19,1));//10011=>10010=>18
		System.out.println(clearLastIBits(19,2));//10011=>10000=>16
		System.out.println(clearLastIBits(19,3));//10011=>10000=>16
		System.out.println(clearLastIBits(19,4));//10011=>10000=>16
		System.out.println(clearLastIBits(19,5));//10011=>00000=>0
	}
}

number is power of two or not application
------------------------------------------
import java.util.*;
class Test 
{
	public static boolean powerOf2(int n){
		return (n & (n-1))==0;
	}
	public static void main(String[] args) 
	{
		for(int i=0;i<=10;i++)
			System.out.println(i+"\t"+powerOf2(i));
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
0       true
1       true
2       true
3       false
4       true
5       false
6       false
7       false
8       true
9       false
10      false

count set bits in a number
--------------------------
import java.util.*;
class Test 
{
	public static int countSetBits(int n){
		int c=0;
		while(n!=0){
			if((n&1)!=0)
				c++;
			n=n>>1;
		}
		return c;
	}
	public static void main(String[] args) 
	{
		for(int i=0;i<=10;i++)
			System.out.println(i+"\t"+countSetBits(i));
	}
}


C:\prakash>javac Test.java

C:\prakash>java Test
0       0
1       1
2       1
3       2
4       1
5       2
6       2
7       3
8       1
9       2
10      2

increment a number by one unit
------------------------------
import java.util.*;
class Test 
{
	public static int increment(int n){
		return -~n;
	}
	public static void main(String[] args) 
	{
		for(int i=0;i<=10;i++)
			System.out.println(i+"\t"+increment(i));
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
0       1
1       2
2       3
3       4
4       5
5       6
6       7
7       8
8       9
9       10
10      11

lower case to upper case conversion:
------------------------------------
import java.util.*;
class Test 
{
	public static String convertToUpperCase(String s){
		String ss="";
		for(int i=0;i<s.length();i++){
			ss=ss+(char)(s.charAt(i)^32);
		}
		return ss;
	}
	public static void main(String[] args) 
	{
		System.out.println(convertToUpperCase("abc"));
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
ABC

upper case to lower case conversion
-----------------------------------
import java.util.*;
class Test 
{
	public static String convertToLowerCase(String s){
		String ss="";
		for(int i=0;i<s.length();i++){
			ss=ss+(char)(s.charAt(i)|32);
		}
		return ss;
	}
	public static void main(String[] args) 
	{
		System.out.println(convertToLowerCase("ABC"));
	}
}

Fast exponetiation calculation application
------------------------------------------
import java.util.*;
class Test 
{
	public static int fastExpo(int a,int n){
		int res=1;
		while(n!=0){
			if((n&1)!=0)
				res = res * a;
			a = a * a;
			n = n>>1;
		}
		return res;
	}

	public static void main(String[] args) 
	{
		System.out.println(fastExpo(2,8));//256
	}
}




Hashtable data structure:
~~~~~~~~~~~~~~~~~~~~~~~~~
01. introduction
02. hashtable
03. operations 
04. hash function
05. implementation of hash table
06. collisions
07. collection resolution methods
08. linear probing & implementation
09. quadratic probing & implementation
10. separate chaining & implementation

introduction:
~~~~~~~~~~~~~
In the case of searching algorithms, consider the problem of searching for a value in an array. if the array is not sorted then we have to compare the given key value with all elements one-by-one, it will take time complexity O(n), if the array is sorted then time complexity is O(logn).

linear ----> O(n)
binary ----> O(logn)

O(n)>O(logn)>O(1)

it is possible to get the location of given key by using some magic method. almost it takes O(1) i.e. constant time. hash method or hash function works just like this magic method.

hashtable
~~~~~~~~~
=> hashtable is a data structure that maps keys to the values.
=> each position of the hashtable is called as slot or bucket.
=> the hashtable uses hash function to calculate an index of a value.(insert/delete/search)

the process of storing data using hash function in a hash table as follows

1) create an array of size 'N'. this array is called as hashtable.
2) find the hashcode of the given data by using hash function.
3) take modulo of hash code with table size to get index of array to store the data.
4) finally store this data in the position that we calculated.

operations 
~~~~~~~~~~
1) insertion 
2) deletion
3) search for data

hash function
~~~~~~~~~~~~~
a hash function or hash method is a function/method that generate index in a table for the given key value/object/ an ideal hash function generates a unique hash value for every value. 

implementation of hash table
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import java.util.*;
class Hashtable{
	int size;
	int a[];
	Hashtable(int size){
		this.size = size;
		a = new int[this.size];
		for(int i=0;i<this.size;i++)
			a[i] = -1;
	}
	void print(){
		System.out.println("content of hash table:");
		for(int i=0;i<size;i++)
			System.out.println(i+" ====> "+a[i]);
	}
	int compute(int value){
		return value%size;
	}
	boolean add(int value){
		int hcode = compute(value);
		if(a[hcode]==-1){
			a[hcode]=value;
			return true;
		}
		return false;
	}
	boolean delete(int value){
		int hcode = compute(value);
		if(a[hcode]!=-1 && a[hcode]==value){
			a[hcode] = -1;
			return true;
		}
		return false;
	}
	boolean search(int value){
		int hcode = compute(value);
		if(a[hcode]==value)
			return true;
		return false;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Hashtable h = new Hashtable(10);
		h.print();
		System.out.println(h.add(23));
		System.out.println(h.add(24));
		System.out.println(h.add(33));
		System.out.println(h.add(50));
		System.out.println(h.add(105));
		System.out.println(h.add(177));
		System.out.println(h.add(777));
		System.out.println(h.add(999));
		h.print();
		System.out.println(h.delete(33));//false
		System.out.println(h.delete(23));//true
		System.out.println(h.delete(100));//true
		h.print();
		System.out.println(h.search(23));//false
		System.out.println(h.search(999));//true
		System.out.println(h.search(100));//false
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
content of hash table:
0 ====> -1
1 ====> -1
2 ====> -1
3 ====> -1
4 ====> -1
5 ====> -1
6 ====> -1
7 ====> -1
8 ====> -1
9 ====> -1
true
true
false
true
true
true
false
true
content of hash table:
0 ====> 50
1 ====> -1
2 ====> -1
3 ====> 23
4 ====> 24
5 ====> 105
6 ====> -1
7 ====> 177
8 ====> -1
9 ====> 999
false
true
false
content of hash table:
0 ====> 50
1 ====> -1
2 ====> -1
3 ====> -1
4 ====> 24
5 ====> 105
6 ====> -1
7 ====> 177
8 ====> -1
9 ====> 999
false
true
false

06. collisions
~~~~~~~~~~~~~~
When a hash function generates the same index/hcode for the two or more different keys, this problem is called as collision. a hash function should return unique address for each key. but practically it is not possible.

properties of a good hash function:
-----------------------------------
1) it should provide a uniform distribution of hash values.
2) choose a hash function, which can be computed quickly and returns unique id.
3) choose a hash function, with a good collision resolution algorithms.
4) choose a hash function, which uses the nessary info provided in the key.
5) it should have a high load factor for given set of keys.

StringBuffer ----> 16 => 34
Hashtable -------> 10 => 20

collision resolution methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hash collisions are practically unavoidable when hashing large number of values. the following are the techniques that are used to find the alternative location in the hash table for the given objects.

1) linear probing
2) quadratic probing
3) seperate chaining

linear probing & implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Insert 3, 13, 23, 33, 43, 53, 63


boolean add(int value){
	int hcode = compute(value);
	for(int i=0;i<size;i++){	
		if(a[hcode]==-1){
			a[hcode]=value;
			return true;
		}
		hcode = hcode + compute1(i);
		hcode = hcode % size;
	}
	return false;
}

There is no proper place for inserting 63 in the hashtable

import java.util.*;
class Hashtable{
	int size;
	int a[];
	Hashtable(int size){
		this.size = size;
		a = new int[this.size];
		for(int i=0;i<this.size;i++)
			a[i] = -1;
	}
	void print(){
		System.out.println("content of hash table:");
		for(int i=0;i<size;i++)
			System.out.println(i+" ====> "+a[i]);
	}
	int compute(int value){
		return value%size;
	}
	int compute1(int index){
		return index;//linear probing
	}
	boolean add(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){	
			if(a[hcode]==-1){
				a[hcode]=value;
				return true;
			}
			hcode = hcode + compute1(i);
			hcode = hcode % size;
		}
		return false;
	}
	boolean delete(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){
			if(a[hcode]!=-1 && a[hcode]==value){
				a[hcode]=-1;
				return true;
			}
			hcode = hcode + compute1(i);
			hcode = hcode % size;
		}
		return false;
	}
	boolean search(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){
			if(a[hcode]==value)
			return true;
			hcode = hcode + compute1(i);
			hcode = hcode % size;
		}		
		return false;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Hashtable h = new Hashtable(10);
		System.out.println(h.add(3));
		System.out.println(h.add(13));
		System.out.println(h.add(23));
		System.out.println(h.add(33));
		System.out.println(h.add(43));
		System.out.println(h.add(53));
		System.out.println(h.add(63));
		h.print();
		System.out.println(h.search(43));//true
		System.out.println(h.search(93));//false
		h.delete(23);
		h.print();
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
true
true
true
true
true
true
false
content of hash table:
0 ====> -1
1 ====> 53
2 ====> -1
3 ====> 3
4 ====> 13
5 ====> -1
6 ====> 23
7 ====> -1
8 ====> 43
9 ====> 33
true
false
content of hash table:
0 ====> -1
1 ====> 53
2 ====> -1
3 ====> 3
4 ====> 13
5 ====> -1
6 ====> -1
7 ====> -1
8 ====> 43
9 ====> 33



quadratic probing & implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

linear ----> compute1(index) ---> index
quadratic--> compute2(index) ---> index*index


objects: 5, 15, 25

import java.util.*;
class Hashtable{
	int size;
	int a[];
	Hashtable(int size){
		this.size = size;
		a = new int[this.size];
		for(int i=0;i<this.size;i++)
			a[i] = -1;
	}
	void print(){
		System.out.println("content of hash table:");
		for(int i=0;i<size;i++)
			System.out.println(i+" ====> "+a[i]);
	}
	int compute(int value){
		return value%size;
	}
	int compute2(int index){
		return index*index;//quadratic probing
	}
	boolean add(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){	
			if(a[hcode]==-1){
				a[hcode]=value;
				return true;
			}
			hcode = hcode + compute2(i);
			hcode = hcode % size;
		}
		return false;
	}
	boolean delete(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){
			if(a[hcode]!=-1 && a[hcode]==value){
				a[hcode]=-1;
				return true;
			}
			hcode = hcode + compute2(i);
			hcode = hcode % size;
		}
		return false;
	}
	boolean search(int value){
		int hcode = compute(value);
		for(int i=0;i<size;i++){
			if(a[hcode]==value)
			return true;
			hcode = hcode + compute2(i);
			hcode = hcode % size;
		}		
		return false;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Hashtable h = new Hashtable(10);
		h.add(5);
		h.add(15);
		h.add(25);
		h.add(35);
		h.add(45);
		h.print();
		System.out.println(h.search(15));//true
		System.out.println(h.search(35));//true
		System.out.println(h.search(45));//false
		h.delete(15);
		h.print();
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
content of hash table:
0 ====> 25
1 ====> -1
2 ====> -1
3 ====> -1
4 ====> -1
5 ====> 5
6 ====> 15
7 ====> -1
8 ====> -1
9 ====> 35
true
true
false
content of hash table:
0 ====> 25
1 ====> -1
2 ====> -1
3 ====> -1
4 ====> -1
5 ====> 5
6 ====> -1
7 ====> -1
8 ====> -1
9 ====> 35


separate chaining & implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In collision handling method chaining is a concept which introduces an additional filed data. i.e. chain. A seperate chain table is maintained for colliding objects, when collision occurrs then a linked list (chain) is maintained at the home bucket.

import java.util.*;
class Hashtable{
	int size;
	Node a[];
	class Node{
		int value;
		Node next;
		Node(int value,Node next){
			this.value = value;
			this.next = next;
		}
	}
	Hashtable(int size){
		this.size = size;
		a = new Node[this.size];
		for(int i=0;i<this.size;i++)
			a[i] = null;
	}
	void print(){
		System.out.println("content of hash table:");
		for(int i=0;i<size;i++)
		{
			Node head = a[i];
			while(head!=null){
				System.out.print(head.value+" => ");
				head = head.next;
			}
			System.out.println("null");
		}	
	}
	int compute(int value){
		return value%size;
	}
	void add(int value){
		int hcode = compute(value);
		a[hcode] = new Node(value,a[hcode]);
	}
	boolean delete(int value){
		int hcode = compute(value);
		Node nextNode, head = a[hcode];
		if(head!=null && head.value==value){
			a[hcode] = head.next;
			return true;
		}
		while(head!=null){
			nextNode = head.next;
			if(nextNode!=null && nextNode.value==value){
				head.next = nextNode.next;
				return true;
			}
			else
				head = nextNode;
		}
		return false;
	}
	boolean search(int value){
		int hcode = compute(value);
		Node head = a[hcode];
		while(head!=null){
			if(head.value == value){
				return true;
			}
			head = head.next;
		}
		return false;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		Hashtable h = new Hashtable(10);
		h.add(13);
		h.add(14);
		h.add(15);
		h.add(16);
		h.add(19);
		h.add(23);
		h.add(33);
		h.add(43);
		h.add(333);
		h.print();
		System.out.println(h.search(333));//true
		System.out.println(h.search(999));//false
		System.out.println(h.delete(333));//true
		h.print();
	}
}

C:\prakash>javac Test.java

C:\prakash>java Test
content of hash table:
null
null
null
333 => 43 => 33 => 23 => 13 => null
14 => null
15 => null
16 => null
null
null
19 => null
true
false
true
content of hash table:
null
null
null
43 => 33 => 23 => 13 => null
14 => null
15 => null
16 => null
null
null
19 => null



Tree Data Structure:
~~~~~~~~~~~~~~~~~~~~

introduction:
-------------
==> non-linear data structure.
==> best suitable for search operations.
==> hierarchical relationships (parent-child)

Ex: Banking application
Ex: Software
Ex: File System
Ex: Family Tree


A tree is a finate set of one or more nodes such that

i) There is a sepcially desinged node called ROOT.
ii) Remaining nodes are partitioned into n>=0 disjoint sets, called as sub-trees

Tree Terminologies
------------------
Root:
-----
It is a unique node, which is not having incoming edges
Ex: A

Node:
-----
Fundamental element of tree, each node has data and two pointers that may be point to null or its children.

Ex: A,B,C,D,E,F,G,H,I

Edge:
-----
it is fundamental part of tree, used to connect two nodes

Ex: AB, AC, AD, BE, BF, BG, EI, DH

Path:
-----
an ordered list of nodes, that are connected by edges called as path

Ex: A to G ---> AB, BG

Leaf Nodes:
-----------
the nodes which is not having any children or outgoing edges

Ex: I, F, G, C, H

Height of tree:
---------------
height of tree is number of edges on the longest path between the root and leaf

Ex: AI--> 3

Level of tree:
--------------
The level of node is the number of edges on the path rom root to that node.

parent:
-------
Node is a parent of all the child nodes that are linked by outgoing edges.

Ex: B,C,D,E

children:
---------
Nodes that are having incoming edges and outgoing edges

Ex: B, C, D, E, 

siblings:
---------
Nodes in the tree what are children of the same parent is called as siblings

Ex: (BCD), (EFG)

ancestor:
---------
A node reachanble through repeated moving from child to parent

Ex: I --> EBA

degree of node:
---------------
The total number of sub-trees attached to the node is called the degree of node.

Ex: De(B) = 3

degree of tree:
---------------
The max degree of all nodes is called as degree of the tree

Ex: de(tree) ---> 3

predecessor:
------------
while displaying or traversing a tree, if a node occurrs previous to some other node, then that node is called as predecessor.

Ex: E is predecessor of I

sucessor:
---------
while displaying or traversing a tree, if a node comes next to some other node is called as successor node.

Ex: E is sucessor of B

Binary Tree
~~~~~~~~~~~
A binary tree is a type of tree in which each node has at most two children (0, 1 or 2) which are referred to as the left child and right child.

In Binary tree each node will have one data filed and two pointers which is pointing to left sub-tree and right sub-tree. the degree of each node in the binary tree will be at the two.

Examples--> diagram

Properties of binary tree
-------------------------
1) max no of nodes on level i of a binary tree is 2^i.
2) there should be exactly one path should be there from root to any node.
3) tree with 'N' nodes has exactly 'N-1' edges connecting these nodes.
4) the height of complete binary tree of N nodes is logN

binary tree representation:
---------------------------
There are two ways are there to represent binary trees

1) sequential representation
2) linked list representation

Each node is sequentially arranged from to to bottom and from left to right let us understand this method, by numering each node the numberign will start from root node and then remaining nodes will given with increasing numbers in level wise direction if the nodes are in same level the numbers will be assiginged from left to right

left(n) = 2n+1
right(n) = 2n+2

n=0 ---> left(A) = 2n+1 = 1 ==> B
         right(A) = 2n+2 = 2 => C

n=2
left(C) = 2n+1 = 2x2+1=5 ----> F
right(C) = 2n+2 = 2x2+2=4+2=6 --> G

In linked list representation each node will be having three files

1) left pointer
2) data
3) right pointer

construction of binary tree using sequential representation:
------------------------------------------------------------
=> pre order
=> post order
=> in order
=> level order

build tree by using preoder
---------------------------

Ex:
---
import java.util.*;
class BT{
	static int index=-1;
	class Node{
		int data;
		Node left;
		Node right;
		Node(int data){
			this.data = data;
			this.left = null;
			this.right = null;
		}
	}
	Node buildTree(int[] nodes){
		index++;
		if(nodes[index]==-1)
			return null;
		Node node = new Node(nodes[index]);
		node.left = buildTree(nodes);
		node.right = buildTree(nodes);
		return node;
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		int[] nodes = {1, 2, 4, -1, -1, 5, -1, -1, 3, -1, 6, -1, -1};
		BT obj = new BT();
		System.out.println(obj.buildTree(nodes).data);//1
	}
}

C:\test>javac Test.java

C:\test>java Test
1

